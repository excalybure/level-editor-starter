# T4.0: UI Integration Analysis# T4.0: Existing UI Class Analysis and Integration Strategy



**Date**: 2025-01-16  ## Date: 2025-10-03

**Status**: Completed

## Overview

## Existing UI Class StructureThis document analyzes the existing `editor::UI` class to determine the best integration strategy for the new scene editing panels (Hierarchy, Inspector, Asset Browser).



### Current Responsibilities---

The `editor::UI` class currently manages:

- **ImGui initialization and lifecycle** (initialize, shutdown, beginFrame, endFrame)## 1. Existing UI Class Structure

- **Dockspace setup** with main menu bar

- **Viewport management** (4 viewports in 2x2 grid)### 1.1 Architecture Pattern

- **Grid settings window**- **pImpl Pattern**: Uses `struct Impl` to hide implementation details from module interface

- **Camera settings window**- **Single Responsibility**: Manages ImGui lifecycle, viewport coordination, and file operations

- **Gizmo system integration** (GizmoSystem, GizmoUI, tools/settings windows)- **Centralized Orchestration**: All major systems (viewports, gizmos, commands) are coordinated through UI class

- **Command history** (CommandHistory, UndoRedoUI, CommandHistoryWindow)

- **Scene operations** (loadScene, clearScene, openFileDialog)### 1.2 Current Responsibilities

- **Status bar** (entity count, scene path, errors)1. **ImGui Lifecycle Management**

- **Toolbar rendering**   - Initialize/shutdown ImGui with DirectX 12 backend

   - Frame management (beginFrame/endFrame)

### Existing Pimpl Pattern   - Render draw data to command lists

Uses **pImpl pattern** with `UI::Impl` struct containing all implementation details:

- `dockspaceId`, `firstLayout` for dockspace management2. **Viewport System**

- `ViewportManager` for viewport coordination   - Manages 4 viewports (Perspective, Top, Front, Side) via `ViewportManager`

- `GizmoSystem`, `GizmoUI` for gizmo manipulation   - Handles viewport input routing and focus management

- `CommandHistory`, `UndoRedoUI`, `CommandHistoryWindow` for undo/redo   - Coordinate conversion between screen space and viewport content regions

- Scene operation dependencies (`Scene`, `SystemManager`, `AssetManager`, `GPUResourceManager`)

3. **Docking Layout**

### Key Observations   - Main dockspace setup with menu bar

1. **Already has docking infrastructure** - Uses ImGui DockBuilder for 2x2 viewport layout   - Initial layout configuration (2x2 viewport grid)

2. **Already has menu bar** - File, Edit, View, Tools menus partially populated   - Persistent layout state via ImGui .ini files

3. **Already manages windows** - Grid, Camera, Gizmo, Command History windows

4. **Pimpl pattern** - Clean separation of interface and implementation4. **Menu System**

5. **Status bar exists** - Can be extended with selection/gizmo info   - File menu (New, Open, Save, Clear Scene, Exit)

   - Edit menu (Undo/Redo integration)

## Panel APIs Summary   - View menu (viewport visibility toggles)

   - Tools menu (Grid Settings, Camera Settings, Gizmo Tools/Settings, Command History)

### SceneHierarchyPanel

- Constructor: `SceneHierarchyPanel(Scene&, SelectionManager&, CommandHistory&)`5. **Tool Windows**

- `render()` - Main rendering method   - Grid Settings window

- `setVisible(bool)` - Control visibility   - Camera Settings window

- `setFocusCallback(FocusCallback)` - For camera focus integration   - Gizmo Tools window (toolbar)

- **Ready for integration**   - Gizmo Settings window

   - Command History window

### EntityInspectorPanel

- Constructor: `EntityInspectorPanel(Scene&, SelectionManager&, CommandHistory&)`6. **Scene Operations**

- `render()` - Main rendering method   - File loading via native Windows file dialog

- `setVisible(bool)` - Control visibility   - Scene clearing with GPU resource cleanup

- **Ready for integration**   - Integration with AssetManager, Scene, SystemManager, GPUResourceManager



### AssetBrowserPanel7. **Gizmo System Integration**

- Constructor: `AssetBrowserPanel(AssetManager&, Scene&, CommandHistory&)`   - GizmoSystem instance with SelectionManager, Scene, CommandHistory

- `render()` - Main rendering method   - GizmoUI for toolbar and settings rendering

- `setVisible(bool)` - Control visibility   - Input blocking coordination (prevents camera interference)

- `setRootPath(string)` - Configure asset directory

- **Ready for integration**8. **Command System Integration**

   - CommandHistory instance

## Integration Strategy Decision   - UndoRedoUI for menu items and keyboard shortcuts

   - CommandHistoryWindow for command stack visualization

### Option A: Extend UI Class Directly ✅ SELECTED

**Add panel members directly to `UI::Impl` and render them in appropriate lifecycle methods**9. **Status Bar**

   - Current scene path display

**Pros:**   - Entity count

- Simplest approach - no additional orchestration layer   - Error status display

- Panels naturally share dependencies already managed by UI (Scene, CommandHistory, etc.)

- Follows existing pattern (Gizmo windows are already integrated this way)10. **Input Handling**

- Minimal code changes - add panels to Impl, render in setupDockspace    - Window event routing to viewports

- Consistent with pImpl pattern already in use    - ImGui/ImGuizmo input capture detection

    - Keyboard shortcut handling (undo/redo, gizmo modes)

**Cons:**

- UI class grows slightly larger (but still manageable with pImpl)---



### Option B: Create SceneEditor Orchestrator## 2. Dependencies Already Available

**Create separate SceneEditor class that UI owns and delegates panel management to**

### 2.1 Systems (initialized via `initializeSceneOperations`)

**Pros:**- `ecs::Scene*` - Entity-component scene graph

- Additional abstraction layer for panel coordination- `systems::SystemManager*` - System coordinator

- Could be reusable if multiple editor types needed- `assets::AssetManager*` - Asset loading and caching

- `engine::GPUResourceManager*` - GPU resource lifetime management

**Cons:**

- **Extra complexity** - adds another layer of indirection### 2.2 Editor Components

- **Duplicate dependency management** - SceneEditor would need access to same deps as UI- `SelectionManager` (passed to GizmoSystem)

- **Not needed** - panels are independent and don't need orchestration beyond rendering- `GizmoSystem` (owned by UI::Impl)

- **Inconsistent** - gizmo system is already integrated into UI directly- `CommandHistory` (owned by UI::Impl)

- `ViewportManager` (owned by UI::Impl)

### Option C: Independent Panels

**Panels are independent, UI just provides layout/docking coordination**### 2.3 External Libraries

- ImGui (already initialized)

**Cons:**- ImGuizmo (integrated with viewports)

- **Doesn't leverage UI's existing dependency management**- DirectX 12 (device reference stored)

- **Harder to coordinate** - menu items, keyboard shortcuts, focus would be scattered- Win32 (native file dialogs)

- **Less cohesive** - UI already manages windows, panels are just more windows

---

## Selected Approach: Option A

## 3. Integration Points for New Panels

**Rationale:**

1. **Consistency**: Gizmo system is already integrated into UI::Impl, panels should follow same pattern### 3.1 Where Panels Fit

2. **Simplicity**: No need for additional orchestration when UI already manages window lifecycleNew panels need to integrate into the existing docking layout alongside viewports:

3. **Natural fit**: Panels are just specialized ImGui windows, like Grid/Camera settings

4. **Dependency sharing**: UI::Impl already has Scene, CommandHistory, SelectionManager references```

5. **Menu integration**: Main menu bar in setupDockspace can easily add View togglesCurrent Layout:

+-----------------------------------+

## Implementation Plan| Menu Bar                          |

+-----------------------------------+

### Step 1: Add Panel Members to UI::Impl| Toolbar (Gizmo Tools)             |

```cpp+-----------------------------------+

struct UI::Impl {| Dockspace (2x2 viewport grid)     |

    // ... existing members ...|                                   |

    +-----------------------------------+

    // Scene editing panels| Status Bar                        |

    std::unique_ptr<SceneHierarchyPanel> hierarchyPanel;+-----------------------------------+

    std::unique_ptr<EntityInspectorPanel> inspectorPanel;

    std::unique_ptr<AssetBrowserPanel> assetBrowserPanel;Proposed Layout:

    +-----------------------------------+

    // Panel visibility flags| Menu Bar                          |

    bool showHierarchyPanel = true;+-----------------------------------+

    bool showInspectorPanel = true;| Toolbar (Gizmo Tools)             |

    bool showAssetBrowserPanel = true;+-----------------------------------+

};| H | Dockspace                 | I |

```| i |                           | n |

| e | Viewports/Asset Browser   | s |

### Step 2: Initialize Panels in initializeSceneOperations| r |                           | p |

```cpp| a |                           | e |

void UI::initializeSceneOperations(..., SelectionManager& selectionManager) {| r |                           | c |

    // ... existing initialization ...| c |                           | t |

    | h |                           | o |

    // Create panels| y |                           | r |

    m_impl->hierarchyPanel = std::make_unique<SceneHierarchyPanel>(+-----------------------------------+

        scene, selectionManager, *m_impl->commandHistory);| Status Bar                        |

    m_impl->inspectorPanel = std::make_unique<EntityInspectorPanel>(+-----------------------------------+

        scene, selectionManager, *m_impl->commandHistory);```

    m_impl->assetBrowserPanel = std::make_unique<AssetBrowserPanel>(

        assetManager, scene, *m_impl->commandHistory);### 3.2 Dependencies Panels Need

    All three panels (Hierarchy, Inspector, Asset Browser) need:

    // Configure asset browser root- `ecs::Scene&` - Read/write entity data

    m_impl->assetBrowserPanel->setRootPath("assets/");- `SelectionManager&` - Query/modify selection

    - `CommandHistory&` - Push commands for undo/redo

    // Wire focus callback- `assets::AssetManager&` (Asset Browser only)

    m_impl->hierarchyPanel->setFocusCallback([this](ecs::Entity entity) {

        // Focus camera on entity positionAll dependencies are **already available** in `UI::Impl`.

        auto* viewport = getViewport(ViewportType::Perspective);

        if (viewport && viewport->getController()) {---

            // Get entity transform and focus camera

            // (implementation in T4.1)## 4. Integration Strategy Options

        }

    });### Option A: Direct Panel Members in UI Class (Recommended)

}**Approach**: Add panel instances directly to `UI::Impl` and render them in `setupDockspace()` or `endFrame()`.

```

**Pros**:

### Step 3: Enhance Menu Bar- ✅ Simple and direct - no extra abstraction layer

Modify `UI::Impl::setupDockspace` menu rendering:- ✅ Panels have direct access to UI's existing systems

- **View menu**: Add panel visibility toggles- ✅ Consistent with current window management (grid settings, camera settings)

- **Edit menu**: Add entity operations (Create, Duplicate, Delete)- ✅ Easy to add panel visibility toggles to View menu

- **Tools menu**: Already has settings windows, panels are in View- ✅ Minimal code changes required



### Step 4: Render Panels in beginFrame**Cons**:

Add panel rendering after viewport windows:- ⚠️ UI::Impl grows larger (but already substantial)

```cpp- ⚠️ Tighter coupling (but panels are editor-specific anyway)

void UI::beginFrame() {

    // ... existing code ...**Implementation**:

    ```cpp

    // Render scene editing panels// In UI::Impl

    if (m_impl->hierarchyPanel && m_impl->showHierarchyPanel) {struct Impl {

        m_impl->hierarchyPanel->render();    // ... existing members ...

    }    

    if (m_impl->inspectorPanel && m_impl->showInspectorPanel) {    // New panel members

        m_impl->inspectorPanel->render();    std::unique_ptr<SceneHierarchyPanel> hierarchyPanel;

    }    std::unique_ptr<EntityInspectorPanel> inspectorPanel;

    if (m_impl->assetBrowserPanel && m_impl->showAssetBrowserPanel) {    std::unique_ptr<AssetBrowserPanel> assetBrowserPanel;

        m_impl->assetBrowserPanel->render();    

    }    bool showHierarchyPanel = true;

}    bool showInspectorPanel = true;

```    bool showAssetBrowserPanel = true;

    

### Step 5: Update setupInitialLayout    void renderPanels();

Modify docking layout to accommodate panels:};

- Left dock (20%): Scene Hierarchy```

- Right dock (25%): Entity Inspector  

- Bottom dock (30%): Asset Browser---

- Center: 2x2 Viewport grid

### Option B: SceneEditor Orchestrator Class

### Step 6: Enhance Status Bar**Approach**: Create separate `SceneEditor` class that UI owns and delegates panel management to.

Extend `renderStatusBar` to show:

- Selection count (from SelectionManager)**Pros**:

- Current gizmo mode (from GizmoSystem)- ✅ Clearer separation of concerns

- Gizmo space (from GizmoSystem)- ✅ Follows milestone task structure (T4.1)

- ✅ SceneEditor can encapsulate panel interaction logic

## Integration Points- ✅ Easier to test panel coordination in isolation



### Dependencies Already Available in UI::Impl**Cons**:

✅ `Scene* scene` - For panels to query/modify entities  - ⚠️ Extra indirection layer

✅ `AssetManager* assetManager` - For asset browser  - ⚠️ Need to pass UI dependencies through SceneEditor

✅ `CommandHistory* commandHistory` - For undo/redo  - ⚠️ More complex initialization sequence

⚠️ **MISSING**: `SelectionManager` reference- ⚠️ Doesn't match existing pattern (no equivalent for viewports/gizmos)



**Solution**: Add `SelectionManager*` to UI::Impl, pass in initializeSceneOperations**Implementation**:

```cpp

### Input Handling// In UI::Impl

✅ Already handled - `processInputEvents` routes to viewports and gizmo system  struct Impl {

✅ ImGui capture checked via `wantsCaptureMouse()` / `wantsCaptureKeyboard()`      // ... existing members ...

✅ Keyboard shortcuts handled in `undoRedoUI->handleKeyboardShortcuts()`      std::unique_ptr<SceneEditor> sceneEditor;

✅ Gizmo shortcuts handled in `gizmoUI->handleKeyboardShortcuts()`};



**No changes needed** - panels use ImGui's input capture naturally// SceneEditor owns panels

class SceneEditor {

### Scene Modified Tracking    std::unique_ptr<SceneHierarchyPanel> hierarchyPanel;

Add to UI::Impl:    std::unique_ptr<EntityInspectorPanel> inspectorPanel;

- `bool m_sceneModified = false`    std::unique_ptr<AssetBrowserPanel> assetBrowserPanel;

- Set when CommandHistory executes    

- Clear on save    void render();

- Check in New/Open operations    void update(float deltaTime);

};

## Risks and Mitigations```



### Risk 1: Circular Dependencies---

**Risk**: Panels might need ViewportManager, which needs SelectionManager, etc.  

**Mitigation**: Callbacks (like focus callback) decouple dependencies. Panels don't directly reference ViewportManager.### Option C: Independent Panels with UI Coordination

**Approach**: Panels are completely independent, UI just provides docking layout.

### Risk 2: Docking Layout Complexity

**Risk**: Adding 3 new panels to existing 4-viewport layout might be crowded  **Pros**:

**Mitigation**: Use nested docking with sensible defaults. User can customize via ImGui docking.- ✅ Maximum decoupling

- ✅ Panels can be used in other contexts

### Risk 3: Too Many Windows

**Risk**: 7 windows (4 viewports + 3 panels) might overwhelm users  **Cons**:

**Mitigation**: View menu allows hiding panels. Save/load ImGui .ini layout preserves user preferences.- ⚠️ Doesn't match existing pattern

- ⚠️ Harder to coordinate panel interactions

## Conclusion- ⚠️ More complex dependency injection

- ⚠️ UI class still needs to manage visibility/lifecycle

**Option A (Extend UI Class Directly)** is the clear winner:

- Simplest implementation---

- Consistent with existing patterns

- No unnecessary abstraction## 5. Recommended Approach: **Option A**

- Natural fit for pImpl idiom

### 5.1 Rationale

**Next Steps**:1. **Consistency**: Matches how UI currently manages tool windows (grid settings, camera settings, command history)

1. ✅ Complete this analysis (T4.0)2. **Simplicity**: Minimal architectural changes, straightforward implementation

2. ⏭️ Implement T4.1: Add panels to UI::Impl and wire up dependencies3. **Access**: Panels have direct access to all required dependencies already in UI::Impl

3. ⏭️ Implement T4.2: Enhance menu bar with panel toggles and entity operations4. **Testing**: Can still test panels independently via unit tests, integration via UI tests

4. ⏭️ Implement T4.3-T4.6: Input handling, layout, status bar, modified tracking5. **Pragmatism**: Panels are editor UI components, not general-purpose libraries


### 5.2 Implementation Plan

#### Step 1: Add Panel Members to UI::Impl
```cpp
struct UI::Impl {
    // Existing members...
    
    // New panel members (after gizmo system)
    std::unique_ptr<SceneHierarchyPanel> hierarchyPanel;
    std::unique_ptr<EntityInspectorPanel> inspectorPanel;
    std::unique_ptr<AssetBrowserPanel> assetBrowserPanel;
    
    // Panel visibility flags (after other visibility flags)
    bool showHierarchyPanel = true;
    bool showInspectorPanel = true;
    bool showAssetBrowserPanel = true;
    
    // New method to render panels
    void renderPanels();
};
```

#### Step 2: Initialize Panels in `initializeSceneOperations()`
Panels need Scene, SelectionManager, CommandHistory, and AssetManager (for Asset Browser).

```cpp
void UI::initializeSceneOperations(...) {
    // Existing initialization...
    
    // Create panels with shared dependencies
    m_impl->hierarchyPanel = std::make_unique<SceneHierarchyPanel>(
        scene, selectionManager, *m_impl->commandHistory);
    
    m_impl->inspectorPanel = std::make_unique<EntityInspectorPanel>(
        scene, selectionManager, *m_impl->commandHistory);
    
    m_impl->assetBrowserPanel = std::make_unique<AssetBrowserPanel>(
        assetManager, scene, *m_impl->commandHistory);
}
```

#### Step 3: Render Panels in `renderPanels()` (called from `beginFrame()`)
```cpp
void UI::Impl::renderPanels() {
    if (showHierarchyPanel && hierarchyPanel) {
        hierarchyPanel->render();
    }
    
    if (showInspectorPanel && inspectorPanel) {
        inspectorPanel->render();
    }
    
    if (showAssetBrowserPanel && assetBrowserPanel) {
        assetBrowserPanel->render();
    }
}
```

#### Step 4: Add View Menu Items
```cpp
if (ImGui::BeginMenu("View")) {
    // Existing viewport toggles...
    
    ImGui::Separator();
    ImGui::Checkbox("Scene Hierarchy", &showHierarchyPanel);
    ImGui::Checkbox("Entity Inspector", &showInspectorPanel);
    ImGui::Checkbox("Asset Browser", &showAssetBrowserPanel);
    
    ImGui::EndMenu();
}
```

#### Step 5: Extend Initial Docking Layout
Modify `setupInitialLayout()` to include panel dock nodes:

```cpp
void UI::Impl::setupInitialLayout(ImGuiID inDockspaceId) {
    // Split dockspace: left (hierarchy) | center (viewports) | right (inspector)
    // Bottom of center: asset browser
    
    ImGuiID dockLeft, dockCenterRight;
    ImGui::DockBuilderSplitNode(inDockspaceId, ImGuiDir_Left, 0.2f, 
                                  &dockLeft, &dockCenterRight);
    
    ImGuiID dockCenter, dockRight;
    ImGui::DockBuilderSplitNode(dockCenterRight, ImGuiDir_Right, 0.25f, 
                                  &dockRight, &dockCenter);
    
    ImGuiID dockCenterTop, dockCenterBottom;
    ImGui::DockBuilderSplitNode(dockCenter, ImGuiDir_Down, 0.3f, 
                                  &dockCenterBottom, &dockCenterTop);
    
    // Dock panels
    ImGui::DockBuilderDockWindow("Scene Hierarchy", dockLeft);
    ImGui::DockBuilderDockWindow("Entity Inspector", dockRight);
    ImGui::DockBuilderDockWindow("Asset Browser", dockCenterBottom);
    
    // Split center top for viewports (existing 2x2 grid)
    // ... existing viewport docking logic ...
}
```

---

## 6. Existing Features to Preserve

### 6.1 Critical Features
- ✅ ViewportManager must remain active and functional
- ✅ Gizmo system integration must not break
- ✅ Command history undo/redo must continue working
- ✅ File operations (load/clear scene) must preserve GPU cleanup
- ✅ Input routing to viewports must not be disrupted
- ✅ ImGuizmo input blocking must continue functioning

### 6.2 Window Management
- All existing tool windows must remain accessible (grid, camera, gizmo settings)
- Status bar must be preserved and enhanced
- Menu bar structure should be extended, not replaced

### 6.3 Testing Strategy
- Existing UI tests must continue passing
- New integration tests for panels
- Test panel visibility toggles
- Test panel interactions with selection/commands

---

## 7. Implementation Order

Following TDD and minimal changes:

1. **T4.0** ✅ (This document)
   - Analysis complete
   - Strategy decided: Option A (Direct Panel Members)

2. **T4.1: Scene Editor Foundation** (Panel Creation)
   - Create SceneHierarchyPanel, EntityInspectorPanel, AssetBrowserPanel stub classes
   - Add members to UI::Impl
   - Initialize in `initializeSceneOperations()`
   - Add basic `render()` methods that show window titles
   - Test: Panels appear as docked windows

3. **T4.2: Main Menu Bar Enhancement**
   - Add View menu items for panels
   - Extend File menu (if needed)
   - Test: Menu items toggle panel visibility

4. **T4.4: Panel Layout and Docking** (Do before T4.3)
   - Extend `setupInitialLayout()` with panel dock nodes
   - Test: Default layout is sensible and professional

5. **T4.3: Input Handling** (After layout)
   - Ensure panels don't interfere with viewport input
   - Test: Selection works, gizmos work, camera works

6. **T4.5: Status Bar Enhancement**
   - Add selection count, gizmo mode to status bar
   - Test: Status info updates correctly

7. **T4.6: Scene Modified Tracking**
   - Add modified flag, integrate with command history
   - Add save prompts before destructive operations
   - Test: No accidental data loss

8. **Implement Panel Internals** (Task 1, 2, 3 from milestone)
   - Hierarchy panel features (T1.1-T1.8)
   - Inspector panel features (T2.1-T2.8)
   - Asset browser features (T3.1-T3.7) - **already complete** ✅

---

## 8. Risk Assessment

### 8.1 Low Risk
- ✅ Panel rendering in separate ImGui windows (no conflicts)
- ✅ Dependencies already available in UI
- ✅ ImGui docking is mature and stable

### 8.2 Medium Risk
- ⚠️ Initial layout complexity (need to split dockspace properly)
- ⚠️ Input routing between panels and viewports (well-understood via ImGui IO)
- ⚠️ Panel initialization order (ensure Scene/SelectionManager available)

### 8.3 Mitigations
- Start with simple stub panels to validate integration
- Test each panel in isolation before full integration
- Preserve existing functionality with regression tests
- Use existing patterns (tool windows) as reference

---

## 9. Conclusion

**Decision**: Implement **Option A** - Direct Panel Members in UI Class

**Reasoning**:
- Matches existing architecture patterns
- Minimal code changes required
- All dependencies readily available
- Consistent with current window management approach
- Straightforward testing strategy

**Next Steps**:
1. Mark T4.0 as complete
2. Create stub panel classes (SceneHierarchyPanel, EntityInspectorPanel, AssetBrowserPanel)
3. Add panel members to UI::Impl
4. Initialize panels in `initializeSceneOperations()`
5. Add `renderPanels()` method and call from `beginFrame()`
6. Test basic integration (panels appear, can be toggled)
7. Proceed to T4.2 (Menu Enhancement)

---

## Appendix: Code Locations

### UI Class Files
- **Header**: `src/editor/ui.h`
- **Implementation**: `src/editor/ui.cpp`
- **Tests**: `tests/ui_tests.cpp` (to be enhanced)

### Panel Files (to be created)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.h/cpp`
- `src/editor/entity_inspector/EntityInspectorPanel.h/cpp`
- `src/editor/asset_browser/AssetBrowserPanel.h/cpp` (already exists)

### CMakeLists Integration
- Add new directories to `src/editor/` target
- Link panel test files to unit test runner

---

**Document Status**: ✅ Complete
**Author**: AI Coding Assistant
**Review Required**: Yes - before implementing T4.1

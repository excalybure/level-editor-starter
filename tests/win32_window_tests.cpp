#include <catch2/catch_all.hpp>

#if defined( _WIN32 )
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
import platform.win32.win32_window;
using platform::Win32Window;
using Catch::Approx;

// Helper to drain all pending events from a window's queue (focus/initial resize, etc.).
static void drainAllEvents( Win32Window &window )
{
	platform::WindowEvent ev;
	while ( window.getEvent( ev ) )
	{
	}
}
#endif

TEST_CASE( "Win32Window create and basic properties", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "TestWindow", 320, 240 ) );
	REQUIRE( window.getHandle() != nullptr );
	int w = 0, h = 0;
	window.getSize( w, h );
	REQUIRE( w == 320 );
	REQUIRE( h == 240 );
	REQUIRE( window.isFocused() == true ); // default value until focus messages arrive
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window empty event queue", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "TestWindow", 100, 100 ) );
	// Drain any initial events (focus/resize) generated by creation
	drainAllEvents( window );
	// Now queue should be empty
	platform::WindowEvent ev;
	REQUIRE_FALSE( window.getEvent( ev ) );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window resize event", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "ResizeWindow", 200, 150 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	// Drain any initial creation events
	drainAllEvents( window );
	int origW = 0, origH = 0;
	window.getSize( origW, origH );
	const int newW = 640, newH = 480;
	REQUIRE( SetWindowPos( hwnd, nullptr, 0, 0, newW, newH, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE ) != 0 );
	// Poll to process WM_SIZE
	REQUIRE( window.poll() );
	platform::WindowEvent ev;
	bool found = false;
	while ( window.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::Resize )
		{
			found = true;
			// Just assert size increased beyond original client size
			REQUIRE( ev.resize.width >= origW );
			REQUIRE( ev.resize.height >= origH );
		}
	}
	REQUIRE( found );
	int w = 0, h = 0;
	window.getSize( w, h );
	REQUIRE( w >= origW );
	REQUIRE( h >= origH );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window mouse move and button events", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "MouseWindow", 200, 150 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	// Drain initial events
	drainAllEvents( window );

	// Mouse move
	const int mx = 42, my = 84;
	REQUIRE( PostMessage( hwnd, WM_MOUSEMOVE, 0, MAKELPARAM( mx, my ) ) != 0 );
	// Left button down/up
	REQUIRE( PostMessage( hwnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM( mx, my ) ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_LBUTTONUP, 0, MAKELPARAM( mx, my ) ) != 0 );
	// Mouse wheel +120 (one detent)
	REQUIRE( PostMessage( hwnd, WM_MOUSEWHEEL, MAKEWPARAM( 0, WHEEL_DELTA ), 0 ) != 0 );

	REQUIRE( window.poll() );

	int moveCount = 0, buttonDownCount = 0, buttonUpCount = 0, wheelCount = 0;
	platform::WindowEvent ev;
	while ( window.getEvent( ev ) )
	{
		switch ( ev.type )
		{
		case platform::WindowEvent::Type::MouseMove:
			moveCount++;
			REQUIRE( ev.mouse.x == Approx( (float)mx ) );
			REQUIRE( ev.mouse.y == Approx( (float)my ) );
			break;
		case platform::WindowEvent::Type::MouseButton:
			if ( ev.mouse.pressed )
			{
				buttonDownCount++;
				REQUIRE( ev.mouse.button == 0 );
			}
			else
			{
				buttonUpCount++;
				REQUIRE( ev.mouse.button == 0 );
			}
			break;
		case platform::WindowEvent::Type::MouseWheel:
			wheelCount++;
			REQUIRE( ev.mouse.wheelDelta == Approx( 1.0f ) );
			break;
		default:
			break;
		}
	}
	REQUIRE( moveCount == 1 );
	REQUIRE( buttonDownCount == 1 );
	REQUIRE( buttonUpCount == 1 );
	REQUIRE( wheelCount == 1 );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window key press/release events", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "KeyWindow", 200, 150 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	drainAllEvents( window );
	constexpr int key = VK_SPACE;
	REQUIRE( PostMessage( hwnd, WM_KEYDOWN, key, 0 ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_KEYUP, key, 0 ) != 0 );
	REQUIRE( window.poll() );

	int pressCount = 0, releaseCount = 0;
	platform::WindowEvent ev;
	while ( window.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::KeyPress )
		{
			pressCount++;
			REQUIRE( ev.keyboard.keycode == key );
			REQUIRE( ev.keyboard.pressed == true );
		}
		if ( ev.type == platform::WindowEvent::Type::KeyRelease )
		{
			releaseCount++;
			REQUIRE( ev.keyboard.keycode == key );
			REQUIRE( ev.keyboard.pressed == false );
		}
	}
	REQUIRE( pressCount == 1 );
	REQUIRE( releaseCount == 1 );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window close event and poll result", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "CloseWindow", 100, 100 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	drainAllEvents( window );
	REQUIRE( PostMessage( hwnd, WM_CLOSE, 0, 0 ) != 0 );
	// After polling, shouldClose flag will be set and poll returns false
	bool stillOpen = window.poll();
	REQUIRE_FALSE( stillOpen );
	platform::WindowEvent ev;
	bool gotClose = false;
	while ( window.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::Close )
			gotClose = true;
	}
	REQUIRE( gotClose );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window focus and lost focus events", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "FocusWindow", 100, 100 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	drainAllEvents( window );
	// Simulate loss of focus then regain
	REQUIRE( PostMessage( hwnd, WM_KILLFOCUS, 0, 0 ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_SETFOCUS, 0, 0 ) != 0 );
	REQUIRE( window.poll() );
	platform::WindowEvent ev;
	std::vector<platform::WindowEvent::Type> types;
	while ( window.getEvent( ev ) )
	{
		types.push_back( ev.type );
	}
	REQUIRE( types.size() == 2 );
	REQUIRE( types[0] == platform::WindowEvent::Type::LostFocus );
	REQUIRE( types[1] == platform::WindowEvent::Type::Focus );
	REQUIRE( window.isFocused() );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window event FIFO ordering", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "OrderWindow", 120, 90 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	drainAllEvents( window );
	// Sequence: mouse move, keydown, keyup, wheel
	REQUIRE( PostMessage( hwnd, WM_MOUSEMOVE, 0, MAKELPARAM( 10, 20 ) ) != 0 );
	constexpr int key = 'A';
	REQUIRE( PostMessage( hwnd, WM_KEYDOWN, key, 0 ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_KEYUP, key, 0 ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_MOUSEWHEEL, MAKEWPARAM( 0, WHEEL_DELTA ), 0 ) != 0 );
	REQUIRE( window.poll() );
	platform::WindowEvent ev;
	std::vector<platform::WindowEvent::Type> types;
	while ( window.getEvent( ev ) )
	{
		types.push_back( ev.type );
	}
	REQUIRE( types.size() == 4 );
	REQUIRE( types[0] == platform::WindowEvent::Type::MouseMove );
	REQUIRE( types[1] == platform::WindowEvent::Type::KeyPress );
	REQUIRE( types[2] == platform::WindowEvent::Type::KeyRelease );
	REQUIRE( types[3] == platform::WindowEvent::Type::MouseWheel );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window multiple windows independence", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window a, b;
	REQUIRE( a.create( "A", 100, 100 ) );
	REQUIRE( b.create( "B", 100, 100 ) );
	HWND ha = static_cast<HWND>( a.getHandle() );
	HWND hb = static_cast<HWND>( b.getHandle() );
	drainAllEvents( a );
	drainAllEvents( b );
	REQUIRE( PostMessage( ha, WM_MOUSEMOVE, 0, MAKELPARAM( 5, 6 ) ) != 0 );
	REQUIRE( PostMessage( hb, WM_MOUSEMOVE, 0, MAKELPARAM( 50, 60 ) ) != 0 );
	// One poll will process both windows' messages
	REQUIRE( a.poll() );
	// Second poll (b) should still return true and not change outcome
	REQUIRE( b.poll() );
	platform::WindowEvent ev;
	int countA = 0, countB = 0;
	float ax = -1, ay = -1, bx = -1, by = -1;
	while ( a.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::MouseMove )
		{
			countA++;
			ax = ev.mouse.x;
			ay = ev.mouse.y;
		}
	}
	while ( b.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::MouseMove )
		{
			countB++;
			bx = ev.mouse.x;
			by = ev.mouse.y;
		}
	}
	REQUIRE( countA == 1 );
	REQUIRE( countB == 1 );
	REQUIRE( ax == Approx( 5.0f ) );
	REQUIRE( ay == Approx( 6.0f ) );
	REQUIRE( bx == Approx( 50.0f ) );
	REQUIRE( by == Approx( 60.0f ) );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window negative mouse wheel", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "WheelWindowNeg", 100, 100 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	drainAllEvents( window );
	REQUIRE( PostMessage( hwnd, WM_MOUSEWHEEL, MAKEWPARAM( 0, -WHEEL_DELTA ), 0 ) != 0 );
	REQUIRE( window.poll() );
	platform::WindowEvent ev;
	bool got = false;
	while ( window.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::MouseWheel )
		{
			got = true;
			REQUIRE( ev.mouse.wheelDelta == Approx( -1.0f ) );
		}
	}
	REQUIRE( got );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window right and middle mouse buttons", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "ButtonsWindow", 100, 100 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	drainAllEvents( window );
	REQUIRE( PostMessage( hwnd, WM_RBUTTONDOWN, MK_RBUTTON, MAKELPARAM( 10, 10 ) ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_RBUTTONUP, 0, MAKELPARAM( 10, 10 ) ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_MBUTTONDOWN, MK_MBUTTON, MAKELPARAM( 15, 15 ) ) != 0 );
	REQUIRE( PostMessage( hwnd, WM_MBUTTONUP, 0, MAKELPARAM( 15, 15 ) ) != 0 );
	REQUIRE( window.poll() );
	int rightDown = 0, rightUp = 0, midDown = 0, midUp = 0;
	platform::WindowEvent ev;
	while ( window.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::MouseButton )
		{
			if ( ev.mouse.button == 1 && ev.mouse.pressed )
				rightDown++;
			else if ( ev.mouse.button == 1 && !ev.mouse.pressed )
				rightUp++;
			else if ( ev.mouse.button == 2 && ev.mouse.pressed )
				midDown++;
			else if ( ev.mouse.button == 2 && !ev.mouse.pressed )
				midUp++;
		}
	}
	REQUIRE( rightDown == 1 );
	REQUIRE( rightUp == 1 );
	REQUIRE( midDown == 1 );
	REQUIRE( midUp == 1 );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window getInstance non-null and idle poll", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "InstanceWindow", 80, 60 ) );
	REQUIRE( window.getInstance() != nullptr );
	drainAllEvents( window );
	// No messages posted; poll should return true and queue stay empty
	REQUIRE( window.poll() );
	platform::WindowEvent ev;
	REQUIRE_FALSE( window.getEvent( ev ) );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window WM_QUIT sets shouldClose", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "QuitWindow", 100, 100 ) );
	drainAllEvents( window );
	PostQuitMessage( 0 );
	bool open = window.poll();
	REQUIRE_FALSE( open );
	// No explicit Close event necessarily, but poll should indicate shutdown
	platform::WindowEvent ev;
	bool any = false;
	while ( window.getEvent( ev ) )
	{
		any = true;
	}
	(void)any; // Accept either path
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window double create prevented", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "First", 50, 50 ) );
	drainAllEvents( window );
	// Second create should fail
	REQUIRE_FALSE( window.create( "Second", 60, 60 ) );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window no duplicate resize events when size unchanged", "[win32][window]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "NoDupResize", 140, 120 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	// Drain initial events
	drainAllEvents( window );
	// Send WM_SIZE with current size values (simulate redundant)
	int w = 0, h = 0;
	window.getSize( w, h );
	REQUIRE( PostMessage( hwnd, WM_SIZE, 0, MAKELPARAM( w, h ) ) != 0 );
	REQUIRE( window.poll() );
	platform::WindowEvent ev;
	bool gotResize = false;
	while ( window.getEvent( ev ) )
	{
		if ( ev.type == platform::WindowEvent::Type::Resize )
			gotResize = true;
	}
	REQUIRE_FALSE( gotResize );
#else
	WARN( "Win32 window tests skipped: not on Win32 platform" );
#endif
}

TEST_CASE( "Win32Window ImGui input integration", "[win32][window][imgui]" )
{
#if defined( _WIN32 )
	Win32Window window;
	REQUIRE( window.create( "ImGuiInputTest", 200, 150 ) );
	HWND hwnd = static_cast<HWND>( window.getHandle() );
	
	// Drain initial events
	drainAllEvents( window );

	// Test that mouse and keyboard events still work after ImGui integration
	// This ensures ImGui_ImplWin32_WndProcHandler is properly integrated
	// and doesn't break existing functionality
	
	SECTION( "Mouse events still processed" )
	{
		const int mx = 100, my = 50;
		REQUIRE( PostMessage( hwnd, WM_MOUSEMOVE, 0, MAKELPARAM( mx, my ) ) != 0 );
		REQUIRE( PostMessage( hwnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM( mx, my ) ) != 0 );
		
		REQUIRE( window.poll() );
		
		int moveCount = 0, buttonCount = 0;
		platform::WindowEvent ev;
		while ( window.getEvent( ev ) )
		{
			if ( ev.type == platform::WindowEvent::Type::MouseMove )
			{
				moveCount++;
				REQUIRE( ev.mouse.x == Catch::Approx( (float)mx ) );
				REQUIRE( ev.mouse.y == Catch::Approx( (float)my ) );
			}
			else if ( ev.type == platform::WindowEvent::Type::MouseButton && ev.mouse.pressed )
			{
				buttonCount++;
				REQUIRE( ev.mouse.button == 0 ); // Left button
			}
		}
		
		// Events should still be processed even with ImGui integration
		REQUIRE( moveCount >= 1 );
		REQUIRE( buttonCount >= 1 );
	}
	
	SECTION( "Keyboard events still processed" )
	{
		const WPARAM vkSpace = VK_SPACE;
		REQUIRE( PostMessage( hwnd, WM_KEYDOWN, vkSpace, 0 ) != 0 );
		REQUIRE( PostMessage( hwnd, WM_KEYUP, vkSpace, 0 ) != 0 );
		
		REQUIRE( window.poll() );
		
		int keyDownCount = 0, keyUpCount = 0;
		platform::WindowEvent ev;
		while ( window.getEvent( ev ) )
		{
			if ( ev.type == platform::WindowEvent::Type::KeyPress )
			{
				keyDownCount++;
				REQUIRE( ev.keyboard.keycode == (int)vkSpace );
				REQUIRE( ev.keyboard.pressed == true );
			}
			else if ( ev.type == platform::WindowEvent::Type::KeyRelease )
			{
				keyUpCount++;
				REQUIRE( ev.keyboard.keycode == (int)vkSpace );
				REQUIRE( ev.keyboard.pressed == false );
			}
		}
		
		// Events should still be processed even with ImGui integration
		REQUIRE( keyDownCount >= 1 );
		REQUIRE( keyUpCount >= 1 );
	}

	SECTION( "Window procedure calls ImGui handler safely" )
	{
		// This test ensures that calling ImGui_ImplWin32_WndProcHandler
		// doesn't crash or interfere with normal message processing
		// Even without ImGui context initialized, the handler should be safe to call
		
		// Send a variety of messages that ImGui typically handles
		REQUIRE( PostMessage( hwnd, WM_MOUSEMOVE, 0, MAKELPARAM( 10, 20 ) ) != 0 );
		REQUIRE( PostMessage( hwnd, WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM( 10, 20 ) ) != 0 );
		REQUIRE( PostMessage( hwnd, WM_CHAR, 'A', 0 ) != 0 );
		REQUIRE( PostMessage( hwnd, WM_KEYDOWN, VK_RETURN, 0 ) != 0 );
		
		// Should not crash and should process messages normally
		REQUIRE( window.poll() );
		
		// Just verify we get some events - the exact count doesn't matter
		// as long as the integration doesn't break message processing
		platform::WindowEvent ev;
		int eventCount = 0;
		while ( window.getEvent( ev ) )
		{
			eventCount++;
		}
		
		REQUIRE( eventCount > 0 );
	}
	
#else
	WARN( "Win32 window ImGui integration tests skipped: not on Win32 platform" );
#endif
}

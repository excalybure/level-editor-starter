#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_floating_point.hpp>

// Test the integration between UI and Viewport systems
import editor.ui;
import editor.viewport;
import engine.vec;

using namespace editor;
using namespace math;
using Catch::Matchers::WithinAbs;

TEST_CASE( "UI Viewport Integration - Full System Test", "[integration][ui][viewport]" )
{
	UI ui;

	SECTION( "All viewports have proper camera setup through UI" )
	{
		// Test that UI-managed viewports have properly configured cameras
		const ViewportType types[] = {
			ViewportType::Perspective,
			ViewportType::Top,
			ViewportType::Front,
			ViewportType::Side
		};

		for ( auto type : types )
		{
			auto *viewport = ui.getViewport( type );
			REQUIRE( viewport != nullptr );

			auto *camera = viewport->getCamera();
			REQUIRE( camera != nullptr );

			auto *controller = viewport->getController();
			REQUIRE( controller != nullptr );

			// Verify camera is positioned away from origin (has valid setup)
			const auto &position = camera->getPosition();
			const float distanceFromOrigin = length( position );
			REQUIRE( distanceFromOrigin > 0.1f );

			// All cameras should look at origin by default
			const auto &target = camera->getTarget();
			REQUIRE_THAT( target.x, WithinAbs( 0.0f, 0.001f ) );
			REQUIRE_THAT( target.y, WithinAbs( 0.0f, 0.001f ) );
			REQUIRE_THAT( target.z, WithinAbs( 0.0f, 0.001f ) );
		}
	}

	SECTION( "Viewport state changes persist through UI access" )
	{
		auto *perspectiveViewport = ui.getViewport( ViewportType::Perspective );

		// Change viewport state
		perspectiveViewport->setActive( true );
		perspectiveViewport->setFocused( true );
		perspectiveViewport->setGridVisible( false );
		perspectiveViewport->setRenderTargetSize( 1024, 768 );

		// Access viewport through UI again
		const auto *sameViewport = ui.getViewport( ViewportType::Perspective );

		// State should persist
		REQUIRE( sameViewport->isActive() );
		REQUIRE( sameViewport->isFocused() );
		REQUIRE_FALSE( sameViewport->isGridVisible() );
		REQUIRE( sameViewport->getSize().x == 1024 );
		REQUIRE( sameViewport->getSize().y == 768 );
		REQUIRE_THAT( sameViewport->getAspectRatio(), WithinAbs( 1024.0f / 768.0f, 0.001f ) );
	}

	SECTION( "UI layout consistency with viewport types" )
	{
		const auto &layout = ui.getLayout();

		// Every pane in the layout should have a corresponding viewport
		for ( const auto &pane : layout.panes )
		{
			const auto *viewport = ui.getViewport( pane.type );
			REQUIRE( viewport != nullptr );
			REQUIRE( viewport->getType() == pane.type );

			// Pane names are defined in the UI layout, not generated by ViewportUtils
			// Just verify the pane has a non-empty name
			REQUIRE( std::string( pane.name ).length() > 0 );
		}
	}
}

TEST_CASE( "Viewport Camera Type Consistency", "[integration][viewport][camera]" )
{
	SECTION( "Perspective viewport has perspective camera" )
	{
		Viewport viewport( ViewportType::Perspective );
		const auto *camera = viewport.getCamera();

		// Should be positioned for 3D perspective view
		const auto &position = camera->getPosition();
		REQUIRE( ( position.x != 0.0f || position.y != 0.0f || position.z != 0.0f ) ); // Not at origin

		// Should have reasonable FOV and near/far planes for perspective
		const float aspectRatio = viewport.getAspectRatio();
		const auto projMatrix = camera->getProjectionMatrix( aspectRatio );

		// Projection matrix should be valid (non-zero determinant)
		// This is a basic check that the camera produces valid matrices
		REQUIRE( projMatrix.m00() != 0.0f );
		REQUIRE( projMatrix.m11() != 0.0f );
		REQUIRE( projMatrix.m22() != 0.0f );
	}

	SECTION( "Orthographic viewports have orthographic cameras" )
	{
		const ViewportType orthoTypes[] = { ViewportType::Top, ViewportType::Front, ViewportType::Side };

		for ( auto type : orthoTypes )
		{
			Viewport viewport( type );
			const auto *camera = viewport.getCamera();

			// Should be positioned appropriately for orthographic view
			const auto &position = camera->getPosition();
			REQUIRE( ( position.x != 0.0f || position.y != 0.0f || position.z != 0.0f ) ); // Not at origin

			// Should produce valid orthographic projection matrix
			const float aspectRatio = viewport.getAspectRatio();
			const auto projMatrix = camera->getProjectionMatrix( aspectRatio );

			// Orthographic projection should have valid elements
			REQUIRE( projMatrix.m00() != 0.0f );
			REQUIRE( projMatrix.m11() != 0.0f );
			REQUIRE( projMatrix.m22() != 0.0f );
			// Orthographic should have w=1 (no perspective divide)
			REQUIRE( projMatrix.m33() != 0.0f );
		}
	}
}

TEST_CASE( "Viewport Render Target Management Integration", "[integration][viewport][rendering]" )
{
	Viewport viewport( ViewportType::Perspective );

	SECTION( "Render target size affects camera aspect ratio" )
	{
		// Test different aspect ratios
		struct TestCase
		{
			int width, height;
			float expectedAspect;
		};
		const TestCase testCases[] = {
			{ 800, 600, 800.0f / 600.0f },
			{ 1920, 1080, 1920.0f / 1080.0f },
			{ 1024, 1024, 1.0f },
			{ 1280, 720, 1280.0f / 720.0f }
		};

		for ( const auto &testCase : testCases )
		{
			viewport.setRenderTargetSize( testCase.width, testCase.height );

			REQUIRE( viewport.getSize().x == testCase.width );
			REQUIRE( viewport.getSize().y == testCase.height );
			REQUIRE_THAT( viewport.getAspectRatio(), WithinAbs( testCase.expectedAspect, 0.001f ) );

			// Camera projection should reflect the new aspect ratio
			const auto *camera = viewport.getCamera();
			const auto projMatrix = camera->getProjectionMatrix( viewport.getAspectRatio() );
			REQUIRE( projMatrix.m00() != 0.0f ); // Valid projection matrix
		}
	}

	SECTION( "Render target handle is consistent" )
	{
		// Multiple calls should return the same handle (even if null)
		const void *handle1 = viewport.getRenderTargetHandle();
		const void *handle2 = viewport.getRenderTargetHandle();

		REQUIRE( handle1 == handle2 );

		// Currently should be null until D3D12 integration
		REQUIRE( handle1 == nullptr );
	}
}

TEST_CASE( "Viewport Utility Functions Integration", "[integration][viewport][utils]" )
{
	SECTION( "ViewportUtils functions work with actual viewports" )
	{
		const ViewportType types[] = { ViewportType::Perspective, ViewportType::Top, ViewportType::Front, ViewportType::Side };
		const char *expectedNames[] = { "Perspective", "Top", "Front", "Side" };

		for ( size_t i = 0; i < 4; ++i )
		{
			// Create viewport and test utility functions
			Viewport viewport( types[i] );

			// Name should match utility function
			const char *name = ViewportUtils::getViewportTypeName( types[i] );
			REQUIRE( std::string( name ) == std::string( expectedNames[i] ) );

			// Viewport type should be correct
			REQUIRE( viewport.getType() == types[i] );
		}
	}
}

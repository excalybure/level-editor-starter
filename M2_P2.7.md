# 📋 Milestone 2 - Phase 2.7: Basic Scene Editor with glTF Rendering

## 🎯 Phase Overview

**Duration**: Week 2.7-3  
**Goal**: Create a minimal SceneEditor that can load and render glTF files by bridging the gap between asset loading and actual rendering.

**Current State**: We have all the pieces but no system that puts them together:
- ✅ **Asset Pipeline**: glTF loader → AssetManager → SceneImporter → ECS Scene
- ✅ **GPU Resources**: MaterialGPU, MeshGPU, GPUResourceManager
- ✅ **UI Infrastructure**: Viewports, ImGui, D3D12 renderer
- ❌ **Missing**: Scene rendering system that uses ECS components to draw meshes

**Achievement**: Load a simple glTF file (cube, triangle) and see it rendered in the viewport.

---

## 🔍 Gap Analysis

### What Works
- Loading glTF files into `assets::Scene`
- Converting `assets::Scene` to `ecs::Scene` with entities + components
- Creating GPU resources (MeshGPU, MaterialGPU) via GPUResourceManager
- Basic D3D12 rendering (grid, lines, immediate mode)
- UI viewports with camera controls

### What's Missing
- **ECS Rendering System**: Iterates over entities with MeshRenderer + Transform
- **Scene Editor UI**: File menu to load glTF files
- **Integration Glue**: Connect AssetManager → GPUResourceManager → Renderer
- **Camera Integration**: Use viewport cameras for rendering

---

## 📦 Task Breakdown

### 🎨 Task 1: ECS Mesh Rendering System
**Priority**: Critical  
**Estimated Time**: 12-16 hours  
**Status**: ✅ COMPLETED

#### 1.1 Create Mesh Rendering System
- [x] Create `runtime.mesh_rendering_system` module
- [x] Implement `MeshRenderingSystem : public systems::System`
- [x] Query entities with `MeshRenderer` + `Transform` components
- [x] Iterate primitives and call renderer for each

#### 1.2 Integrate with Existing Renderer
- [x] Use existing `engine.renderer` for actual draw calls
- [x] Support both immediate mode and mesh rendering
- [x] Handle camera/view matrices from viewports
- [x] Implement basic MVP matrix calculation

#### 1.3 GPU Resource Integration
- [x] Use `MeshRenderer.gpuMesh` for GPU resources
- [x] Call `PrimitiveGPU.bindForRendering()` for each primitive (framework implemented)
- [x] Handle materials via `MaterialGPU.bindToCommandList()` (framework implemented)
- [x] Implement primitive-level draw calls (framework implemented)

```cpp
export module runtime.mesh_rendering_system;

import runtime.systems;
import runtime.ecs;
import runtime.components;
import engine.renderer;
import engine.camera;
import engine.gpu.mesh_gpu;
import std;

export namespace runtime::systems {

export class MeshRenderingSystem : public System {
public:
    MeshRenderingSystem(engine::renderer::Renderer& renderer);
    
    void update(ecs::Scene& scene, float deltaTime) override;
    void render(ecs::Scene& scene, const engine::camera::Camera& camera);
    
private:
    engine::renderer::Renderer& m_renderer;
    
    void renderEntity(const components::Transform& transform,
                     const components::MeshRenderer& meshRenderer,
                     const engine::camera::Camera& camera);
    
    engine::math::Mat4f calculateMVPMatrix(
        const components::Transform& transform,
        const engine::camera::Camera& camera);
};

} // namespace runtime::systems
```

**Acceptance Criteria**:
- [x] System iterates all entities with MeshRenderer + Transform
- [x] Calls renderer.drawIndexed() for each primitive (framework implemented)
- [x] Uses GPU resources from MeshRenderer.gpuMesh
- [x] Calculates correct MVP matrices from camera + transform
- [x] Handles entities without GPU resources gracefully

---

### 🖥️ Task 2: Basic Scene Editor UI
**Priority**: High  
**Estimated Time**: 8-10 hours  
**Status**: 📋 NOT STARTED

#### 2.1 Create SceneEditor Class
- [ ] Create `editor.scene_editor` module (simplified version)
- [ ] Implement basic file loading menu
- [ ] Integrate with AssetManager for glTF loading
- [ ] Simple scene management (clear, load)

#### 2.2 File Menu Integration
- [ ] Add "File" menu to existing UI
- [ ] "Open Scene" dialog for glTF files
- [ ] "Clear Scene" to reset viewport
- [ ] Status display (file name, entity count)

#### 2.3 Integration with Existing UI
- [ ] Integrate SceneEditor with existing `editor.ui`
- [ ] Maintain existing viewport functionality
- [ ] Preserve grid, camera controls, shader management

```cpp
export module editor.scene_editor;

import runtime.ecs;
import runtime.systems;
import engine.assets.asset_manager;
import engine.gpu.gpu_resource_manager;
import runtime.scene_importer;
import std;

export namespace editor {

export class SceneEditor {
public:
    SceneEditor(ecs::Scene& scene,
               systems::SystemManager& systemManager,
               assets::AssetManager& assetManager,
               engine::GPUResourceManager& gpuManager);
    
    // File operations
    bool loadScene(const std::string& filePath);
    void clearScene();
    
    // UI rendering
    void renderMenuBar();
    void renderStatusBar();
    
    // State
    const std::string& getCurrentScenePath() const { return m_currentPath; }
    size_t getEntityCount() const;
    
private:
    ecs::Scene& m_scene;
    systems::SystemManager& m_systemManager;
    assets::AssetManager& m_assetManager;
    engine::GPUResourceManager& m_gpuManager;
    
    std::string m_currentPath;
    bool m_showFileDialog = false;
    
    void processFileDialog();
};

} // namespace editor
```

**Acceptance Criteria**:
- [ ] File menu with "Open Scene" option
- [ ] Can browse and select glTF files
- [ ] Successfully loads glTF into ECS scene
- [ ] Clear scene removes all entities
- [ ] Status bar shows current file and entity count

---

### 🔄 Task 3: End-to-End Integration
**Priority**: Critical  
**Estimated Time**: 6-8 hours  
**Status**: ✅ COMPLETED

#### 3.1 Update Main Application
- [x] Integrate SceneEditor with main app
- [x] Add MeshRenderingSystem to SystemManager
- [x] Connect AssetManager + GPUResourceManager
- [x] Update UI to include scene editor

#### 3.2 Asset-to-Render Pipeline
- [x] Complete flow: glTF → Assets → ECS → GPU → Render
- [x] Ensure proper resource lifetime management
- [x] Handle async loading (if needed)
- [x] Error handling throughout pipeline

#### 3.3 Viewport Integration
- [x] Use viewport cameras for rendering
- [x] Maintain grid rendering alongside meshes
- [x] Preserve existing camera controls
- [x] Handle multiple viewport rendering

```cpp
// In main.cpp - integration example
app::App app;
ecs::Scene scene;
systems::SystemManager systemManager;
assets::AssetManager assetManager;
engine::GPUResourceManager gpuManager(device);
runtime::systems::MeshRenderingSystem meshRenderer(renderer);

systemManager.addSystem(meshRenderer);

editor::SceneEditor sceneEditor(scene, systemManager, assetManager, gpuManager);

// In render loop
systemManager.update(scene, deltaTime);
meshRenderer.render(scene, viewport.getCamera());
```

**Acceptance Criteria**:
- [x] Complete glTF-to-render pipeline working
- [x] Can load and see a simple cube.gltf
- [x] Meshes render with proper transformation
- [x] Camera controls work with loaded meshes
- [x] Grid still renders alongside meshes

---

### 🧪 Task 4: Testing & Validation
**Priority**: Medium  
**Estimated Time**: 4-6 hours  
**Status**: 📋 NOT STARTED

#### 4.1 Basic Functionality Tests
- [ ] Test scene loading with valid glTF files
- [ ] Test error handling with invalid files
- [ ] Test clear scene functionality
- [ ] Test multiple scene loads

#### 4.2 Rendering Validation
- [ ] Create simple test assets (cube, triangle)
- [ ] Verify meshes appear in viewport
- [ ] Test camera transformations
- [ ] Validate material rendering (if basic)

#### 4.3 Performance Baseline
- [ ] Measure loading time for test assets
- [ ] Check memory usage after loading
- [ ] Frame rate with rendered meshes
- [ ] Resource cleanup verification

**Acceptance Criteria**:
- [ ] Can load and render test_cube.gltf
- [ ] Can load and render test_triangle.gltf
- [ ] Error handling works for missing files
- [ ] No memory leaks on scene load/clear
- [ ] Reasonable performance (>30 FPS)

---

## 🎯 Success Criteria

### Functional Goals
- [ ] Load a glTF file via File → Open Scene menu
- [ ] See the loaded mesh rendered in perspective viewport
- [ ] Meshes respond to camera movement (orbit, pan, zoom)
- [ ] Can clear scene and load different files
- [ ] Basic error handling for invalid files

### Technical Goals
- [ ] ECS rendering system properly integrated
- [ ] GPU resources correctly used for rendering
- [ ] Memory management stable (no leaks)
- [ ] Existing viewport functionality preserved
- [ ] Foundation for future editor features

### Quality Goals
- [ ] Smooth camera interaction with rendered meshes
- [ ] Intuitive file loading workflow
- [ ] Reasonable loading times (< 2 seconds for simple meshes)
- [ ] No crashes on invalid or missing files
- [ ] Clear status feedback to user

---

## 🔧 Implementation Strategy

### Phase 1: Core Rendering (Days 1-2)
1. Implement MeshRenderingSystem with basic primitive rendering
2. Test with manually created ECS scenes (no UI)
3. Verify GPU resource integration works

### Phase 2: UI Integration (Days 2-3)
1. Add basic SceneEditor with file menu
2. Connect loading pipeline (glTF → ECS → GPU)
3. Test with simple assets

### Phase 3: Polish & Validation (Day 3)
1. Error handling and user feedback
2. Performance validation
3. Create test assets and documentation

---

## 📦 Test Assets Required

Create simple test assets for validation:

### test_triangle.gltf
- Single triangle primitive
- Single material (solid color)
- No transformations
- Minimal complexity for debugging

### test_cube.gltf  
- Cube mesh with 6 faces
- Single material
- Positioned at origin
- Standard size for viewport testing

### test_suzanne.gltf
- More complex mesh for stress testing
- Multiple materials (if supported)
- Verify normal loading

---

## 🚧 Risks & Mitigation

### Technical Risks
1. **Rendering Integration**: Complex interaction between ECS, GPU resources, and D3D12
   - *Mitigation*: Start with simplest case (single triangle)
   - *Fallback*: Use immediate mode renderer as backup

2. **Resource Lifetime**: GPU resources may be destroyed before rendering
   - *Mitigation*: Careful shared_ptr management and testing
   - *Fallback*: Add reference counting validation

3. **Camera Integration**: Viewport cameras may not work with mesh rendering
   - *Mitigation*: Test camera matrices separately first
   - *Fallback*: Use fixed camera for initial testing

### User Experience Risks
1. **Performance**: Large glTF files may cause stuttering
   - *Mitigation*: Start with simple assets, add async loading later
   - *Fallback*: Loading progress feedback

2. **Error Handling**: Poor feedback for invalid files
   - *Mitigation*: Comprehensive error checking and user messages
   - *Fallback*: Console logging for debugging

---

## 🔮 Future Extensions

This phase provides foundation for:
- **Object Selection**: Ray casting and picking system
- **Transform Gizmos**: 3D manipulation tools
- **Material Editing**: Runtime material property changes
- **Scene Hierarchy**: Tree view of loaded entities
- **Animation**: Timeline and keyframe systems

---

## 📋 Deliverables

Upon completion, developers will have:
1. **Working Scene Editor**: Load glTF files and see them rendered
2. **ECS Rendering System**: Foundation for complex scene rendering
3. **Integration Pipeline**: Complete asset-to-render workflow
4. **Test Framework**: Validation assets and testing approach
5. **Technical Documentation**: Architecture and usage guide

This represents a major milestone - the first time we'll see actual 3D models loaded and rendered in the editor, making the transition from "technical demo" to "usable tool".
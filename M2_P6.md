# Milestone 2 - Phase 6: Scene Editing UI

## üìã Overview

**Phase**: 6 of 6  
**Duration**: Week 6-7 (2 weeks)  
**Dependencies**: Phases 1-5 (ECS, Assets, Picking, Gizmos, Commands)

**Goal**: Create a complete scene editing user interface with hierarchy panel, entity inspector, asset browser, and integrated scene editor. This phase ties together all previous systems into a cohesive editing experience.

---

## üéØ Objectives

1. Build scene hierarchy panel with tree view and drag-and-drop reparenting
2. Create entity inspector panel for component editing
3. Implement asset browser for importing and managing assets
4. Develop integrated scene editor orchestrating all panels
5. Add context menus and keyboard shortcuts for common operations
6. Implement scene save/load functionality
7. Support multi-selection across all UI panels

---

## üèóÔ∏è Architecture Overview

### Component Structure
```
src/editor/
‚îú‚îÄ‚îÄ scene_hierarchy/
‚îÇ   ‚îú‚îÄ‚îÄ SceneHierarchyPanel.h            # Tree view of entities
‚îÇ   ‚îî‚îÄ‚îÄ SceneHierarchyPanel.cpp
‚îú‚îÄ‚îÄ entity_inspector/
‚îÇ   ‚îú‚îÄ‚îÄ EntityInspectorPanel.h           # Component editing UI
‚îÇ   ‚îú‚îÄ‚îÄ EntityInspectorPanel.cpp
‚îÇ   ‚îú‚îÄ‚îÄ ComponentUI.h                    # UI helpers for components
‚îÇ   ‚îî‚îÄ‚îÄ ComponentUI.cpp
‚îú‚îÄ‚îÄ asset_browser/
‚îÇ   ‚îú‚îÄ‚îÄ AssetBrowserPanel.h              # Asset management UI
‚îÇ   ‚îî‚îÄ‚îÄ AssetBrowserPanel.cpp
‚îî‚îÄ‚îÄ scene_editor/
    ‚îú‚îÄ‚îÄ SceneEditor.h                    # Main orchestrator
    ‚îî‚îÄ‚îÄ SceneEditor.cpp
```

### Integration Points
- **Selection System**: All panels interact with `SelectionManager`
- **Command System**: All edits go through `CommandHistory` for undo/redo
- **Gizmo System**: Inspector and hierarchy trigger gizmo operations
- **Asset Pipeline**: Asset browser integrates with `AssetManager`
- **ECS**: All panels read/write to `ecs::Scene`
- **Existing UI Class**: Panels should integrate with existing `editor::UI` class which already manages:
  - Viewport system and ViewportManager
  - Grid and camera settings windows
  - Gizmo tools and settings windows
  - Command history window
  - File operations (loadScene, clearScene)
  - Main menu bar and docking layout

### Hierarchy Implementation Note
- The ECS uses **implicit hierarchy** via `Scene::setParent()`, `Scene::getParent()`, and `Scene::getChildren()` methods
- No explicit `Hierarchy` component exists - parent/child relationships are stored in Scene's internal maps
- UI panels access hierarchy through Scene methods, not through component queries

---

## üì¶ Task Breakdown

### Task 1: Scene Hierarchy Panel Foundation

#### T1.1: Basic Tree View Rendering
**Atomic Functionality**: Display flat list of entities

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.h` (new)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (new)
- `tests/scene_hierarchy_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `SceneHierarchyPanel` class
2. Add constructor taking `Scene&`, `SelectionManager&`, `CommandHistory&`
3. Implement `render()` method with ImGui window
4. Add `renderEntityTree()` to iterate over all entities
5. Display entity names using `components::Name`
6. Handle entities without name component (show "Entity [ID]")

**Test Cases**:
- Empty scene renders without errors
- Scene with entities displays all entity names
- Entities without name show ID fallback
- Panel can be hidden/shown via `setVisible()`

**Acceptance**:
- Tree view displays all entities in scene
- Entity names are readable and formatted
- No crashes with empty or malformed scenes

---

#### T1.2: Hierarchical Tree Structure
**Atomic Functionality**: Display parent-child relationships

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.h` (modify)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderEntityNode(Entity, bool isRoot)` for recursive rendering
2. Use ImGui tree nodes for hierarchical display
3. Query Scene's hierarchy methods: `scene.getParent(entity)` and `scene.getChildren(entity)`
   - Note: No `Hierarchy` component exists; use Scene's hierarchy API directly
4. Indent child entities appropriately
5. Add expand/collapse functionality (ImGui built-in)
6. Display hierarchy icons (parent/child indicators)

**Test Cases**:
- Root entities display at top level
- Child entities are indented under parents
- Deep hierarchies (5+ levels) render correctly
- Expand/collapse state persists during frame

**Acceptance**:
- Clear visual hierarchy with indentation
- Tree nodes expand/collapse smoothly
- Deep hierarchies are navigable

---

#### T1.3: Selection Integration
**Atomic Functionality**: Clicking entity selects it

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Check `ImGui::IsItemClicked()` on each entity node
2. Call `SelectionManager::select()` on click
3. Support Ctrl+Click for multi-selection
4. Support Shift+Click for range selection
5. Highlight selected entities with different color
6. Query `SelectionManager::isSelected()` for rendering

**Test Cases**:
- Single click selects entity
- Ctrl+Click adds/removes from selection
- Shift+Click selects range
- Selected entities highlight correctly
- Selection synchronizes with other systems

**Acceptance**:
- Intuitive selection behavior matching standard UIs
- Multi-selection works correctly
- Visual feedback is clear

---

#### T1.4: Drag-and-Drop Reparenting
**Atomic Functionality**: Drag entity onto another to change parent

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/commands/HierarchyCommands.h` (new)
- `src/editor/commands/HierarchyCommands.cpp` (new)
- `tests/scene_hierarchy_tests.cpp` (modify)
- `tests/hierarchy_command_tests.cpp` (new)

**Implementation Steps**:
1. Add `m_draggedEntity` member variable
2. Use `ImGui::BeginDragDropSource()` on entity nodes
3. Set payload with entity ID
4. Use `ImGui::BeginDragDropTarget()` on target nodes
5. Create `ReparentEntityCommand` class
6. Implement `execute()` and `undo()` for reparenting
   - Use `scene.setParent(entity, newParent)` to update hierarchy
   - Store old parent for undo operation
7. Push command to `CommandHistory` on drop
8. Verify circular reference prevention (cannot parent to descendant)

**Test Cases**:
- Dragging entity changes parent
- Cannot drag entity onto itself
- Cannot drag parent onto its own child (circular)
- Undo/redo restores previous parent
- World transform remains constant during reparent

**Acceptance**:
- Drag-and-drop feels natural and responsive
- Circular references prevented
- Undo/redo works correctly
- World positions preserved

---

#### T1.5: Context Menu
**Atomic Functionality**: Right-click shows entity operations

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance from Phase 5)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderContextMenu(Entity)` method
2. Check `ImGui::IsItemClicked(ImGuiMouseButton_Right)`
3. Open popup with `ImGui::OpenPopup("EntityContextMenu")`
4. Add menu items:
   - Create Child Entity
   - Duplicate (copies entity and all components)
   - Delete (with confirmation dialog for entities with children)
   - Rename (triggers inline editing)
   - Copy (future: copy to clipboard)
   - Paste (future: paste from clipboard)
5. Wire menu items to existing commands from Phase 5:
   - Use `CreateEntityCommand` for Create Child
   - Use `DeleteEntityCommand` for Delete
   - Use `RenameEntityCommand` for Rename
6. Implement `DuplicateEntityCommand` that:
   - Creates new entity
   - Copies all components from source
   - Adjusts name (append " Copy")
   - Preserves hierarchy if duplicating with children (recursive)
   - Positions near original (slight offset)
7. Show different menu for empty space (Create Root Entity)

**Test Cases**:
- Right-click opens context menu
- Create Child adds child entity
- Duplicate clones entity with components
- Delete removes entity (with confirmation)
- Rename initiates inline editing

**Acceptance**:
- Context menu appears near cursor
- All operations work as expected
- Menu closes after action

---

#### T1.6: Inline Rename
**Atomic Functionality**: Double-click entity to rename

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/commands/ComponentCommands.h` (new)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add `m_renameEntity` and `m_renameBuffer` members
2. Check `ImGui::IsItemHovered() && ImGui::IsMouseDoubleClicked()`
3. Switch to `ImGui::InputText()` for editing
4. Create `ModifyComponentCommand<Name>` generic command
5. Submit command on Enter or lost focus
6. Cancel on Escape key

**Test Cases**:
- Double-click starts rename mode
- Enter confirms new name
- Escape cancels rename
- Lost focus confirms name
- Undo/redo restores previous name

**Acceptance**:
- Rename feels intuitive and responsive
- Command system captures all name changes
- No duplicate names allowed (optional validation)

---

#### T1.7: Focus Selected Entity (Frame in View) ‚úÖ COMPLETED
**Atomic Functionality**: F key focuses camera on selected entity

**Status**: ‚úÖ COMPLETED (2025-01-16)
- Callback-based API implemented (setFocusCallback, requestFocus)
- F key shortcut integrated with ImGui::IsKeyPressed(ImGuiKey_F)
- 4 test cases, 14 assertions - all passing
- Tests: `unit_test_runner.exe "*Focus*"` or `"[T1.7]"`
- Ready for ViewportManager integration to call focusOnPoint()

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.h` (modified)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modified)
- `tests/scene_hierarchy_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added FocusCallback typedef using std::function<void(ecs::Entity)>
2. ‚úÖ Implemented setFocusCallback() to register camera focus callback
3. ‚úÖ Implemented requestFocus() with entity validation and callback invocation
4. ‚úÖ Added F key detection in render() with ImGui::IsWindowFocused() check
5. ‚úÖ Integrated with SelectionManager to focus first selected entity
6. ‚úÖ Camera API verified: PerspectiveCameraController::focusOnPoint() ready to use

**Test Cases** (all passing):
- ‚úÖ Focus callback can be set and invoked
- ‚úÖ Focus with no callback does not crash (safety check)
- ‚úÖ Focus calculates entity bounds from Transform component
- ‚úÖ F key triggers focus when panel has focus

**Acceptance** (achieved):
- ‚úÖ Callback pattern enables testing without ViewportManager dependency
- ‚úÖ F key provides quick navigation to selected entities
- ‚úÖ Safe handling of missing callbacks and invalid entities
- ‚úÖ Ready for final integration with camera controller

**Integration Notes**:
- Wire callback in UI class: `hierarchyPanel.setFocusCallback([this](ecs::Entity e) { viewport->getController()->focusOnPoint(transform->position, 10.0f); });`
- Camera focus uses smooth transitions (FocusState with ease-out interpolation)
- ViewportManager::getActiveViewport() ‚Üí Viewport::getController() ‚Üí cast to PerspectiveCameraController

---

#### T1.8: Search and Filter
**Atomic Functionality**: Filter entities by name in hierarchy

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add search input field at top of hierarchy panel
2. Add `m_searchFilter` string member
3. Filter entity display based on search string
4. Support case-insensitive search
5. Highlight matching entities
6. Optionally expand parent nodes to show matches
7. Show "X of Y entities" count when filtering
8. Add clear button (X) to search field

**Test Cases**:
- Empty search shows all entities
- Search filters by entity name
- Case-insensitive matching works
- Parent nodes expand to show matches
- Clear button resets filter

**Acceptance**:
- Fast search even with 1000+ entities
- Intuitive filtering behavior
- Clear indication of filtered state

---

### Task 2: Entity Inspector Panel

#### T2.1: Inspector Panel Foundation
**Atomic Functionality**: Display selected entity info

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.h` (new)
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (new)
- `tests/entity_inspector_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `EntityInspectorPanel` class
2. Add constructor taking same dependencies as hierarchy panel
3. Implement `render()` with ImGui window
4. Check `SelectionManager::getSelectedEntities()`
5. Show "No Selection" message if empty
6. Show "Multiple Selected" if more than one
7. Add `renderEntityHeader(Entity)` for entity info

**Test Cases**:
- No selection shows appropriate message
- Single selection shows entity header
- Multi-selection shows count
- Panel can be hidden/shown

**Acceptance**:
- Inspector displays for selected entity
- Clear messaging for edge cases
- Clean UI layout

---

#### T2.2: Component UI Helpers
**Atomic Functionality**: Reusable UI widgets for component editing

**Files**:
- `src/editor/entity_inspector/ComponentUI.h` (new)
- `src/editor/entity_inspector/ComponentUI.cpp` (new)
- `tests/component_ui_tests.cpp` (new)

**Implementation Steps**:
1. Create `ComponentUI` utility class with static methods
2. Add `renderVec3Control(label, Vec3&, resetValue, speed)`
3. Use `ImGui::DragFloat3()` with custom formatting
4. Add reset button (right-click or dedicated button)
5. Add `renderFloatControl(label, float&, min, max)`
6. Use color coding for X/Y/Z axes (red/green/blue)
7. Return `bool` indicating if value changed

**Test Cases**:
- Vec3 control allows editing all components
- Reset button restores default value
- Color coding is visible and clear
- Float control respects min/max bounds

**Acceptance**:
- Intuitive drag-to-edit behavior
- Visual feedback for value changes
- Consistent styling across all controls

---

#### T2.3: Transform Component Editor
**Atomic Functionality**: Edit entity position, rotation, scale

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/entity_inspector/ComponentUI.cpp` (modify)
- `src/editor/commands/ComponentCommands.h` (enhance)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderTransformComponent(Entity)` method
2. Get `Transform` component from entity
3. Use `ComponentUI::renderVec3Control()` for position, rotation, scale
4. Create `ModifyTransformCommand` if value changed
5. Support command merging for continuous dragging
6. Show local vs world toggle (future enhancement placeholder)
7. Format rotation as degrees (convert from radians internally)

**Test Cases**:
- Position drag updates entity transform
- Rotation shows in degrees
- Scale affects all axes or individual
- Undo/redo restores previous transform
- Commands merge during continuous drag

**Acceptance**:
- Smooth editing experience
- Values update in real-time
- Undo/redo works perfectly
- Changes reflect in viewport immediately

---

#### T2.4: Name and Visible Component Editors
**Atomic Functionality**: Edit entity name and visibility

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/entity_inspector/ComponentUI.cpp` (modify)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `ComponentUI::renderName(Name&)`
2. Use `ImGui::InputText()` for name editing
3. Create command on text change
4. Add `ComponentUI::renderVisible(Visible&)`
5. Use `ImGui::Checkbox()` for visibility toggle
6. Create command on state change

**Test Cases**:
- Name input updates entity name
- Visibility checkbox toggles visibility
- Commands support undo/redo
- Changes propagate to hierarchy panel

**Acceptance**:
- Text input feels responsive
- Checkbox is clear and obvious
- All changes are undoable

---

#### T2.5: MeshRenderer Component Editor
**Atomic Functionality**: Edit mesh and material references

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/entity_inspector/ComponentUI.cpp` (modify)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `ComponentUI::renderMeshRenderer(MeshRenderer&, AssetManager&)`
2. Display mesh information:
   - Show mesh handle or "None" if no mesh
   - Display number of primitives if mesh is loaded
   - Show GPU resource status (loaded/not loaded)
3. Add "Browse" button to open asset selector (future)
4. For now, show read-only information
5. Display local bounding box dimensions
6. Show LOD bias slider (editable)
7. Future: Show material overrides per primitive (requires primitive-level editing)
8. Note: Actual mesh/material assignment should create commands for undo/redo

**Test Cases**:
- Mesh path displays correctly
- Primitive list shows all primitives
- Material overrides display for each primitive
- Future: Changing values creates commands

**Acceptance**:
- Clear display of mesh structure
- Primitive-based architecture is visible
- Foundation for future asset selector

---

#### T2.6: Add Component Menu
**Atomic Functionality**: Add new components to entity

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderAddComponentButton(Entity)` method
2. Show "Add Component" button at bottom of inspector
3. Open popup menu with component types
4. List available components:
   - Transform (note: usually auto-added)
   - MeshRenderer
   - Visible
   - Selected (editor component)
   - Future: Custom components
5. Create `AddComponentCommand<T>` generic command
6. Disable already-present components in menu
7. Initialize new components with default values

**Test Cases**:
- Button shows component type menu
- Adding component succeeds
- Duplicate components are disabled
- Undo removes the component
- New component appears in inspector

**Acceptance**:
- Easy to discover available components
- Clear which components are already present
- Commands work correctly

---

#### T2.7: Remove Component Menu
**Atomic Functionality**: Remove components from entity

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderComponentContextMenu(Entity, componentType)` method
2. Add small "‚ãÆ" button next to each component header
3. Open popup with "Remove Component" option
4. Create `RemoveComponentCommand<T>` generic command
5. Store component data for undo
6. Prevent removing essential components (Name, Transform)

**Test Cases**:
- Context menu appears on button click
- Removing component succeeds
- Essential components cannot be removed
- Undo restores component with original data
- Component disappears from inspector

**Acceptance**:
- Clear affordance for removal
- Safeguards against breaking entity
- Full undo/redo support

---

#### T2.8: Multi-Selection Support
**Atomic Functionality**: Show common properties for multiple entities

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderMultiSelectionInfo()` method
2. Show count of selected entities
3. List common components shared by all
4. Show "‚Äî" for properties with different values
5. Editing common property affects all entities
6. Create batch commands for multi-entity edits
7. Disable add/remove component for multi-selection

**Test Cases**:
- Multi-selection shows entity count
- Common properties are editable
- Different values show placeholder
- Batch command affects all selected
- Undo/redo works for batch operations

**Acceptance**:
- Intuitive behavior for multi-selection
- Clear indication of common vs different properties
- Batch operations feel snappy

---

### Task 3: Asset Browser Panel

#### T3.1: Basic File System Navigation ‚úÖ COMPLETED
**Atomic Functionality**: Display directory contents

**Status**: ‚úÖ COMPLETED (2025-10-03)
- Header and implementation files created
- File system navigation with std::filesystem
- Directory sorting (directories first, alphabetically)
- Safe handling of empty/non-existent paths
- 6 test cases, 14 assertions - all passing
- Tests: `unit_test_runner.exe "[AssetBrowser][T3.1]"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (new)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (new)
- `tests/asset_browser_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `AssetBrowserPanel` class
2. Add constructor taking `AssetManager&`, `Scene&`, `CommandHistory&`
3. Implement `render()` with ImGui window
4. Add `m_rootPath` and `m_currentPath` members
5. Use `std::filesystem` to enumerate directories
6. Add `getDirectoryContents(path)` helper
7. Add `isDirectory(path)` helper
8. Display directories and files in list

**Test Cases**:
- Root directory displays correctly
- Subdirectories are recognized
- Files show appropriate icons/names
- Empty directories show message

**Acceptance**:
- Clear file system representation
- Directories and files distinguishable
- No crashes with invalid paths

---

#### T3.2: Directory Tree View ‚úÖ COMPLETED
**Atomic Functionality**: Navigate folder hierarchy

**Status**: ‚úÖ COMPLETED (2025-10-03)
- Recursive tree rendering with ImGui tree nodes
- Click handling to navigate directories
- Current directory highlighting with Selected flag
- Leaf node detection and optimization
- Split-panel layout (tree left, contents right)
- 2 test cases, 4 assertions - all passing
- Tests: `unit_test_runner.exe "[AssetBrowser][T3.2]"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (modify)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

---

#### T3.3: Path Breadcrumbs ‚úÖ COMPLETED
**Atomic Functionality**: Show and navigate current path

**Status**: ‚úÖ COMPLETED (2025-10-03)
- navigateToParent() with root boundary checking implemented
- getPathSegments() returns breadcrumb path with name-path pairs
- renderPathBar() with up button and clickable segment buttons
- Boundary protection (cannot navigate above root)
- 2 test cases, 9 assertions - all passing
- Tests: `unit_test_runner.exe "[AssetBrowser][T3.3]"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (modified)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modified)
- `tests/asset_browser_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added navigateToParent() method with root boundary checking
2. ‚úÖ Added getPathSegments() returning vector of (name, path) pairs
3. ‚úÖ Added renderPathBar() method with up button
4. ‚úÖ Split current path into clickable segments
5. ‚úÖ Rendered each segment as button with "/" separators
6. ‚úÖ Up button conditionally shown when not at root
7. ‚úÖ Integrated breadcrumbs into main render() method

**Test Cases** (all passing):
- ‚úÖ navigateToParent boundary checks (root, subdirectory, deep paths)
- ‚úÖ getPathSegments returns correct breadcrumb structure

**Acceptance** (achieved):
- ‚úÖ Easy navigation to any parent folder via breadcrumb clicks
- ‚úÖ Clear indication of current location in file system
- ‚úÖ Matches standard file browser UX patterns
- ‚úÖ Safe boundary checking prevents navigation above root

---

#### T3.4: Asset Grid View
**Atomic Functionality**: Display assets as thumbnails

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderAssetGrid()` method
2. Use `ImGui::BeginChild()` for scrollable region
3. Arrange assets in grid layout (4-6 columns)
4. Show file icon based on type (mesh, material, texture)
5. Display filename below icon
6. Add `getAssetTypeFromExtension()` helper
7. Support .gltf, .glb, .obj for meshes (focus on .gltf)

**Test Cases**:
- Assets display in grid layout
- File types show correct icons
- Scrolling works with many assets
- Grid resizes with window

**Acceptance**:
- Clean, browsable asset view
- File types easily identifiable
- Responsive layout

---

#### T3.4: Asset Grid View ‚úÖ COMPLETED
**Atomic Functionality**: Display assets as thumbnails in grid layout

**Status**: ‚úÖ COMPLETED (2025-10-03)
- AssetType enum for file type classification (Mesh, Texture, Material, Unknown)
- getAssetTypeFromExtension() with case-insensitive extension matching
- getFileContents() filters files from directories (excludes subdirectories)
- renderAssetGrid() displays files in responsive grid layout (4-6 columns)
- File type icons displayed based on extension ([M], [T], [Mat], [?])
- Filename display with truncation for long names
- 2 test cases, 11 assertions - all passing
- Tests: `unit_test_runner.exe "*asset types*"` and `"*filters files*"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (modified)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modified)
- `tests/asset_browser_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added AssetType enum with Mesh, Texture, Material, Unknown values
2. ‚úÖ Implemented getAssetTypeFromExtension() with case-insensitive matching
3. ‚úÖ Added getFileContents() helper to filter only files (not directories)
4. ‚úÖ Implemented renderAssetGrid() with responsive column calculation
5. ‚úÖ Grid layout uses cell size 100px + 10px padding
6. ‚úÖ Column count adapts to available width (minimum 1 column)
7. ‚úÖ File type icons rendered as placeholders ([M], [T], [Mat], [?])
8. ‚úÖ Filename truncation for long names (15 chars + "...")
9. ‚úÖ Empty directories show "(no assets in this directory)" message

**Test Cases** (all passing):
- ‚úÖ GLTF/GLB files identified as Mesh type
- ‚úÖ Unknown extensions return Unknown type
- ‚úÖ Case-insensitive extension matching
- ‚úÖ Files without extensions handled correctly
- ‚úÖ getFileContents returns only files, not directories
- ‚úÖ Empty directories return empty list
- ‚úÖ Non-existent paths handled gracefully

**Acceptance** (achieved):
- ‚úÖ Clean, browsable grid view matching standard file browsers
- ‚úÖ File types easily identifiable via icons
- ‚úÖ Responsive layout adapts to window width
- ‚úÖ No crashes with empty directories or invalid paths
- ‚úÖ Foundation ready for T3.5 (Asset Selection and Preview)

---

#### T3.5: Asset Selection and Preview ‚úÖ COMPLETED
**Atomic Functionality**: Select asset to see details

**Status**: ‚úÖ COMPLETED (2025-10-03)
- Asset selection tracking with m_selectedAsset member
- Selection methods: selectAsset(), clearSelection(), getSelectedAsset()
- AssetMetadata struct for file information (exists, type, filename, sizeBytes)
- getAssetMetadata() retrieves file information using std::filesystem
- Split-panel layout with 250px preview panel when asset selected
- Selection highlighting in grid (blue color for selected items)
- Preview panel displays filename (wrapped), type, size (KB/MB), clear button
- 2 test cases, 13 assertions - all passing
- Tests: `unit_test_runner.exe "[AssetBrowser][T3.5]"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (modified)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modified)
- `tests/asset_browser_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added AssetMetadata struct with exists, type, filename, sizeBytes fields
2. ‚úÖ Added m_selectedAsset string member for tracking current selection
3. ‚úÖ Implemented selectAsset(), clearSelection(), getSelectedAsset() methods
4. ‚úÖ Implemented getAssetMetadata() using std::filesystem for file info
5. ‚úÖ Modified render() for split layout with conditional preview panel
6. ‚úÖ Updated renderAssetGrid() to highlight selected item with blue color
7. ‚úÖ Grid buttons call selectAsset() on click
8. ‚úÖ Implemented renderAssetPreview() showing asset details
9. ‚úÖ Preview displays filename (wrapped), type, size in KB or MB
10. ‚úÖ "Clear Selection" button to deselect asset
11. ‚úÖ Handles missing files gracefully (shows "Asset not found")

**Test Cases** (all passing):
- ‚úÖ Initial state has no selection
- ‚úÖ selectAsset() updates current selection
- ‚úÖ clearSelection() removes selection
- ‚úÖ Selecting different asset replaces previous selection
- ‚úÖ getSelectedAsset() returns current selection
- ‚úÖ getAssetMetadata() returns correct file information
- ‚úÖ Metadata includes file size, type, filename
- ‚úÖ Non-existent files return exists=false in metadata

**Acceptance** (achieved):
- ‚úÖ Clear selection feedback with blue highlighting
- ‚úÖ Useful metadata display in preview panel
- ‚úÖ Foundation for future 3D thumbnail preview system
- ‚úÖ Robust error handling for missing files

---

#### T3.6: Asset Import ‚úÖ COMPLETED
**Atomic Functionality**: Import new assets into project

**Status**: ‚úÖ COMPLETED (2025-10-03)
- importAsset() method with filesystem copy and validation
- Import Asset button with ImGui text input popup dialog
- File type validation (only supported asset types)
- Source file existence and regular file checks
- Duplicate/overwrite handling with canonical path comparison
- Error handling for filesystem operations
- 2 test cases, 9 assertions - all passing
- Tests: `unit_test_runner.exe "[AssetBrowser][T3.6]"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (modified)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modified)
- `tests/asset_browser_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added "Import Asset" button to path bar toolbar
2. ‚úÖ Added importAsset(filePath) method with validation and copy logic
3. ‚úÖ Implemented ImGui text input popup for file path (native dialog placeholder)
4. ‚úÖ Asset type validation using getAssetTypeFromExtension()
5. ‚úÖ File copy to current directory with std::filesystem::copy_file()
6. ‚úÖ Duplicate/overwrite support with canonical path comparison
7. ‚úÖ Error display in popup for failed imports

**Test Cases** (all passing):
- ‚úÖ importAsset copies file to current directory successfully
- ‚úÖ importAsset returns false for non-existent source files
- ‚úÖ importAsset returns false for unsupported file types
- ‚úÖ importAsset handles duplicate filenames (overwrite/same location)

**Acceptance** (achieved):
- ‚úÖ Simple import workflow with text input popup
- ‚úÖ Error handling for invalid files and filesystem issues
- ‚úÖ Assets immediately available after import (file copied to directory)
- ‚úÖ Robust path handling with canonical comparison

---

#### T3.7: Drag-and-Drop to Scene ‚úÖ COMPLETED
**Atomic Functionality**: Drag asset from browser to scene

**Status**: ‚úÖ COMPLETED (2025-10-03)
- canDragAsset() method for checking draggable asset types
- getDragDropPayload() method returning asset path as payload
- ImGui drag-drop source integration in renderAssetGrid()
- Drag visual showing filename during drag operation
- Payload type "ASSET_BROWSER_ITEM" for drop target identification
- Currently supports Mesh assets (.gltf, .glb) for dragging
- 1 test case, 7 assertions - all passing
- Tests: `unit_test_runner.exe "*drag*"`

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (modified)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modified)
- `tests/asset_browser_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added canDragAsset() method to check if asset type supports dragging
2. ‚úÖ Added getDragDropPayload() method to generate payload string
3. ‚úÖ Integrated ImGui::BeginDragDropSource() in asset grid rendering
4. ‚úÖ Set drag-drop payload with type "ASSET_BROWSER_ITEM" and asset path
5. ‚úÖ Display filename as drag visual using ImGui::Text()
6. ‚úÖ ImGui::EndDragDropSource() to complete drag source setup
7. ‚úÖ Asset path validation for draggable assets (Mesh types only)

**Test Cases** (all passing):
- ‚úÖ getDragDropPayload returns asset path for mesh files (.gltf, .glb)
- ‚úÖ getDragDropPayload returns empty string for unsupported types
- ‚úÖ canDragAsset returns true for supported mesh formats
- ‚úÖ canDragAsset returns false for unsupported file types

**Acceptance** (achieved):
- ‚úÖ Drag-and-drop source implemented in asset grid
- ‚úÖ Visual feedback during drag (filename tooltip)
- ‚úÖ Payload ready for drop targets (viewport, hierarchy panels)
- ‚úÖ Type-safe payload with identifiable "ASSET_BROWSER_ITEM" type
- ‚úÖ Foundation for future CreateEntityFromAssetCommand implementation

**Notes:**
- Drop target implementation deferred to viewport/hierarchy panel integration
- Entity creation from asset will be implemented when viewport accepts drops
- Current implementation provides complete drag source - drop handling separate concern
- Payload contains full asset path for drop target to load asset
- Only Mesh assets currently draggable (extensible to Texture, Material later)

---

### Task 4: Scene Editor Integration

#### T4.0: Existing UI Class Analysis and Refactoring
**Atomic Functionality**: Understand and refactor existing UI integration points

**Files**:
- `src/editor/ui.h` (analyze)
- `src/editor/ui.cpp` (analyze)
- Review existing integration patterns

**Implementation Steps**:
1. Review existing `UI` class structure and responsibilities
2. Identify what functionality already exists (file loading, menu bar, docking)
3. Plan integration approach: extend UI class vs separate SceneEditor orchestrator
4. Document public API that panels will need from UI
5. Consider whether SceneEditor should be a member of UI or UI should create panels directly
6. Review existing `Impl` pattern used by UI class
7. Decide on ownership model for panels (UI owns vs SceneEditor owns)

**Design Decisions Required**:
- **Option A**: Add panel members directly to `UI` class and render them in UI::endFrame()
- **Option B**: Create `SceneEditor` class that UI owns and delegates panel management to
- **Option C**: Panels are independent and UI just provides layout/docking coordination

**Test Cases**:
- N/A - This is an analysis and design task

**Acceptance**:
- Clear integration strategy documented
- No conflicts with existing UI functionality
- Plan for maintaining existing features while adding new panels

---

#### T4.1: Scene Editor Foundation
**Atomic Functionality**: Orchestrate all panels

**Files**:
- `src/editor/scene_editor/SceneEditor.h` (new)
- `src/editor/scene_editor/SceneEditor.cpp` (new)
- `tests/scene_editor_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `SceneEditor` class
2. Add members for all panels and systems
3. Implement `initialize()` to create panels
4. Instantiate `SelectionManager`, `CommandHistory`
5. Create panel instances with shared dependencies
6. Implement `shutdown()` for cleanup
7. Add `update(deltaTime)` for per-frame logic

**Test Cases**:
- Editor initializes without errors
- All panels are created
- Shutdown cleans up properly
- No memory leaks

**Acceptance**:
- Clean initialization/shutdown
- All systems interconnected
- Ready for UI rendering

---

#### T4.2: Main Menu Bar Enhancement
**Atomic Functionality**: Extend existing menu with scene editing operations

**Files**:
- `src/editor/ui.cpp` (modify existing menu bar)
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Review existing menu bar in `UI::renderMainMenuBar()` (if it exists)
2. Add "Scene" or "Edit" menu section for scene operations
3. Add menu items: Create Entity, Delete Entity, Duplicate
4. Add "View" menu section with panel toggles:
   - Show/Hide Scene Hierarchy
   - Show/Hide Entity Inspector
   - Show/Hide Asset Browser
5. Wire "Edit" menu to command history (Undo/Redo)
6. Add "Create" menu with entity primitives and empty entity
7. Ensure menu items enable/disable based on selection state
8. Integrate with existing file operations (New Scene, Open, Save, Save As)

**Test Cases**:
- Menu bar displays correctly
- All menu items are clickable
- Keyboard shortcuts work (Ctrl+N, Ctrl+S, etc.)
- Menu items enable/disable appropriately

**Acceptance**:
- Standard menu bar UX
- All common operations accessible
- Keyboard shortcuts functional

---

#### T4.3: Input Handling
**Atomic Functionality**: Route input to appropriate systems

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Implement `handleKeyboardInput()` method
2. Check `ImGui::GetIO().WantCaptureKeyboard`
3. Route keys to command history (Ctrl+Z, Ctrl+Y)
4. Route keys to selection (Delete for entities)
5. Route keys to gizmo system (W/E/R for modes)
6. Implement `handleMouseInput()` method
7. Check `ImGui::GetIO().WantCaptureMouse`
8. Route clicks to picking system if not over UI

**Test Cases**:
- Ctrl+Z triggers undo
- Ctrl+Y triggers redo
- Delete removes selected entities
- W/E/R switches gizmo modes
- Mouse input ignored when over UI

**Acceptance**:
- Responsive keyboard controls
- No input conflicts with UI
- Standard editor shortcuts work

---

#### T4.4: Panel Layout and Docking
**Atomic Functionality**: Arrange panels in window

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Add `setupUI()` method called in `render()`
2. Use `ImGui::DockSpaceOverViewport()` for docking
3. Define default layout on first run
4. Hierarchy panel on left (20% width)
5. Inspector panel on right (25% width)
6. Asset browser on bottom (30% height)
7. Viewport in center (remaining space)
8. Save/load layout with `ImGui::SaveIniSettingsToDisk()`

**Test Cases**:
- Default layout is sensible
- Panels can be dragged and docked
- Layout persists across sessions
- Reset layout menu item works

**Acceptance**:
- Professional editor layout
- Flexible panel arrangement
- User customization supported

---

#### T4.5: Status Bar
**Atomic Functionality**: Show editor state information

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderStatusBar()` method
2. Use `ImGui::BeginViewportSideBar()` at bottom
3. Show entity count, selection count
4. Show command history position (undo stack depth)
5. Show current gizmo mode and space
6. Show frame time and FPS
7. Add separator between sections

**Test Cases**:
- Status bar displays at bottom
- All information updates in real-time
- Counts are accurate
- Performance metrics are readable

**Acceptance**:
- Useful at-a-glance information
- Unobtrusive placement
- Clear formatting

---

#### T4.6: Scene Modified Tracking
**Atomic Functionality**: Track unsaved changes

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Add `m_sceneModified` flag
2. Set flag when any command executes
3. Clear flag on save
4. Add asterisk to window title when modified
5. Add `handleSceneModification()` helper
6. Show warning dialog on New/Open with unsaved changes
7. Offer Save/Don't Save/Cancel options

**Test Cases**:
- Flag sets on entity modification
- Flag clears on save
- Window title shows asterisk
- Warning appears when appropriate
- User can cancel dangerous operations

**Acceptance**:
- No accidental data loss
- Clear indication of unsaved work
- Standard save prompt behavior

---

### Task 5: Scene Serialization ‚úÖ COMPLETED (2025-01-17)

**Status**: ‚úÖ All atomic functionalities implemented and tested with TDD methodology

#### T5.1: Scene Save Format Design ‚úÖ COMPLETED
**Atomic Functionality**: Define JSON schema for scenes

**Status**: ‚úÖ COMPLETED (2025-01-17)
- JSON schema version 1.0 with comprehensive documentation
- Entity arrays with component serialization (Transform, Visible, MeshRenderer)
- Hierarchy preservation via parent entity ID references
- Scene metadata (name, version, timestamp)
- Error handling enums (FileNotFound, InvalidJSON, UnsupportedVersion)
- 250+ line documentation with examples and best practices

**Files**:
- `docs/scene_format.md` (created)
- `src/runtime/scene_serialization/SceneSerializer.h` (created)
- `tests/scene_serialization_tests.cpp` (created)

**Implementation Steps**:
1. Design JSON schema for scene data
2. Include entities array with components
3. Store transform as position, rotation, scale
4. Store hierarchy as parent entity IDs
5. Store mesh renderer as asset paths
6. Include scene metadata (name, version)
7. Create example scene JSON for reference

**Example Schema**:
```json
{
  "version": "1.0",
  "name": "My Scene",
  "entities": [
    {
      "id": 1,
      "name": "Camera",
      "components": {
        "transform": {
          "position": [0, 5, -10],
          "rotation": [0.2, 0, 0, 0.98],
          "scale": [1, 1, 1]
        }
      }
    },
    {
      "id": 2,
      "name": "Cube",
      "parent": null,
      "components": {
        "transform": { "position": [0, 0, 0], "rotation": [0, 0, 0, 1], "scale": [1, 1, 1] },
        "meshRenderer": {
          "meshPath": "assets/models/cube.gltf",
          "materialOverrides": []
        },
        "visible": true
      }
    }
  ]
}
```

**Test Cases**:
- Schema covers all component types
- JSON is human-readable
- Handles entity references correctly
- Backward compatible (version field)

**Acceptance**:
- Complete scene representation
- Easy to parse and generate
- Extensible for future components

---

#### T5.2: Scene Save Implementation ‚úÖ COMPLETED
**Atomic Functionality**: Serialize scene to JSON file

**Status**: ‚úÖ COMPLETED (2025-01-17)
- SceneSerializer static class with saveScene() method
- std::expected<void, SerializationError> error handling
- Component serialization: Transform, Visible, MeshRenderer
- Entity ID mapping and hierarchy preservation
- ISO 8601 timestamp generation for metadata
- Anonymous namespace for private helper functions
- nlohmann/json integration via vcpkg
- 3 test cases passing: empty scene, single entity, error handling

**Files**:
- `src/runtime/scene_serialization/SceneSerializer.h` (created)
- `src/runtime/scene_serialization/SceneSerializer.cpp` (created)
- `tests/scene_serialization_tests.cpp` (modified)
- `CMakeLists.txt` (modified: added nlohmann_json dependency)
- `vcpkg.json` (modified: added nlohmann-json package)

**Implementation Steps** (completed):
1. ‚úÖ Created SceneSerializer class with static saveScene() method
2. ‚úÖ Added nlohmann/json to vcpkg.json dependencies
3. ‚úÖ Implemented entity iteration and component serialization
4. ‚úÖ Created helper functions: serializeTransform, serializeVisible, serializeMeshRenderer
5. ‚úÖ Implemented entity ID to index mapping for references
6. ‚úÖ Serialized parent references correctly using entity IDs
7. ‚úÖ Wrote formatted JSON to file with proper indentation
8. ‚úÖ Added error handling for file I/O (FileWriteFailed)
9. ‚úÖ Generated ISO 8601 timestamps for metadata
10. ‚úÖ Used std::expected for modern C++23 error handling

**Test Cases** (all passing):
- ‚úÖ Empty scene saves successfully with metadata
- ‚úÖ Scene with entities serializes all components correctly
- ‚úÖ Invalid file paths return FileWriteFailed error
- ‚úÖ JSON output is human-readable and well-formatted

**Acceptance** (achieved):
- ‚úÖ Reliable scene saving with comprehensive error handling
- ‚úÖ Human-readable JSON output with proper formatting
- ‚úÖ Error messages are clear and actionable
- ‚úÖ All components serialize with correct data types

---

#### T5.3: Scene Load Implementation ‚úÖ COMPLETED
**Atomic Functionality**: Deserialize scene from JSON file

**Status**: ‚úÖ COMPLETED (2025-01-17)
- loadScene() method with JSON parsing and entity creation
- Entity ID remapping via std::unordered_map
- Component deserialization with proper type handling
- Hierarchy rebuilding in two-pass algorithm
- Error handling for invalid JSON and missing files
- Helper functions: deserializeTransform, deserializeVisible, deserializeMeshRenderer
- 3 test cases passing: empty scene load, round-trip, error handling

**Files**:
- `src/runtime/scene_serialization/SceneSerializer.cpp` (modified)
- `tests/scene_serialization_tests.cpp` (modified)

**Implementation Steps** (completed):
1. ‚úÖ Added loadScene(Scene&, filepath) method with std::expected return
2. ‚úÖ Implemented JSON file parsing with error handling
3. ‚úÖ Cleared existing scene entities (without confirmation - future enhancement)
4. ‚úÖ Created entities from JSON array in order
5. ‚úÖ Mapped old entity IDs to new Entity handles via std::unordered_map
6. ‚úÖ Restored all components with deserialized data
7. ‚úÖ Rebuilt hierarchy relationships in second pass (after all entities exist)
8. ‚úÖ Added validation for missing required fields
9. ‚úÖ Handled referenced assets (TODO: AssetManager integration deferred)
10. ‚úÖ Implemented robust error handling (FileNotFound, InvalidJSON)

**Test Cases** (all passing):
- ‚úÖ Valid scene file loads successfully
- ‚úÖ Empty scene loads without errors
- ‚úÖ Save/load round-trip is lossless (all data preserved)
- ‚úÖ Invalid file path returns FileNotFound error
- ‚úÖ Entity IDs are remapped correctly during load
- ‚úÖ Hierarchy is reconstructed accurately

**Acceptance** (achieved):
- ‚úÖ Reliable scene loading with comprehensive validation
- ‚úÖ Robust error handling for all failure modes
- ‚úÖ Assets referenced but not yet loaded via AssetManager (TODO noted)
- ‚úÖ Lossless round-trip: save ‚Üí load ‚Üí verify all data intact

**Notes**:
- AssetManager::getInstance() calls commented out (not yet available)
- Entity ID remapping ensures correct hierarchy after load
- Two-pass algorithm: create all entities first, then set parents
- ISO 8601 timestamps parsed for metadata (not currently used)

---

#### T5.4: Scene Editor Save/Load Integration
**Atomic Functionality**: Wire serialization to editor UI

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Create `SceneSerializer` class with static methods
2. Add `saveScene(Scene&, filepath)` method
3. Use nlohmann/json (add to vcpkg.json if needed)
4. Iterate all entities and serialize components
5. Handle entity ID to index mapping
6. Serialize parent references correctly
7. Write formatted JSON to file
8. Add error handling for file I/O

**Test Cases**:
- Empty scene saves successfully
- Scene with entities serializes all components
- Hierarchy relationships are preserved
- Save/load round-trip is lossless
- Invalid paths return errors

**Acceptance**:
- Reliable scene saving
- Human-readable output
- Error messages are helpful

---

#### T5.3: Scene Load Implementation
**Atomic Functionality**: Deserialize scene from JSON file

**Files**:
- `src/runtime/scene_serialization/SceneSerializer.cpp` (modify)
- `tests/scene_serialization_tests.cpp` (modify)

**Implementation Steps**:
1. Add `loadScene(Scene&, filepath)` method
2. Parse JSON file with error handling
3. Clear existing scene entities (with confirmation)
4. Create entities from JSON array
5. Map old entity IDs to new entities
6. Restore all components with data
7. Rebuild hierarchy relationships
8. Load referenced assets via AssetManager

**Test Cases**:
- Valid scene file loads successfully
- Invalid JSON shows error message
- Entity IDs are remapped correctly
- Hierarchy is reconstructed
- Assets are loaded automatically

**Acceptance**:
- Reliable scene loading
- Robust error handling
- Assets load on demand

---

#### T5.4: Scene Editor Save/Load Integration ‚úÖ COMPLETED
**Atomic Functionality**: Wire serialization to editor UI

**Status**: ‚úÖ COMPLETED (2025-01-17)
- newScene(), saveScene(), loadScene() methods implemented in UI class
- File‚ÜíSave menu item wired to saveScene() (or Save As if no path)
- File‚ÜíSave As menu item added with openSaveFileDialog()
- File‚ÜíNew updated to call newScene() with save prompts
- File‚ÜíOpen updated to use SceneSerializer instead of AssetManager
- Unsaved changes dialogs enhanced with save/don't save/cancel logic
- .scene file extension used for scene files (not .gltf)
- Error handling with scene::SerializationErrorInfo messages
- All 6 AFs implemented and integrated

**Files**:
- `src/editor/ui.h` (modified: added newScene(), saveScene(), openSaveFileDialog())
- `src/editor/ui.cpp` (modified: implementation + File menu updates)

**Implementation Steps** (completed):
1. ‚úÖ Implemented newScene() method - clears scene, resets path, clears modified flag
2. ‚úÖ Implemented saveScene(filepath) using scene::SceneSerializer::saveScene()
3. ‚úÖ Added error handling switch for scene::SerializationError enum values
4. ‚úÖ Implemented openSaveFileDialog() with GetSaveFileNameA and .scene filter
5. ‚úÖ Updated File‚ÜíSave menu item to call saveScene() or openSaveFileDialog()
6. ‚úÖ Added File‚ÜíSave As menu item (Ctrl+Shift+S) calling openSaveFileDialog()
7. ‚úÖ Updated File‚ÜíNew unsaved changes dialog to save before new
8. ‚úÖ Updated File‚ÜíOpen unsaved changes dialog to save before open
9. ‚úÖ Replaced loadScene() implementation to use scene::SceneSerializer instead of AssetManager
10. ‚úÖ Changed openFileDialog() filter from .gltf to .scene files

**Test Cases**:
- Note: UI integration tests require full ImGui context and DirectX device per instructions ¬ß9
- Manual validation required for file dialog interactions
- Serialization validated via existing scene_serialization_tests.cpp (6 tests, 24 assertions passing)
- Round-trip save/load tested via unit tests

**Acceptance** (achieved):
- ‚úÖ Complete save/load workflow integrated into File menu
- ‚úÖ Unsaved changes warnings prevent accidental data loss
- ‚úÖ File dialogs use appropriate filters (.scene for scenes)
- ‚úÖ Error messages displayed from SceneSerializer results
- ‚úÖ Current scene path tracked and updated after save/load
- ‚úÖ Scene modified flag cleared after successful save
- ‚úÖ All menu items functional with keyboard shortcuts

**Notes**:
- scene:: namespace used for SceneSerializer (not runtime::)
- SerializationErrorInfo struct contains error enum + message + filePath
- Save As dialog uses GetSaveFileNameA with OFN_OVERWRITEPROMPT flag
- Open dialog changed from .gltf filter to .scene filter
- AssetManager/SceneImporter no longer used for scene loading (replaced by SceneSerializer)
- File‚ÜíNew and File‚ÜíOpen dialogs properly save before proceeding if user chooses
- Build successful with only minor warnings (unrelated to changes)

---

### Task 6: Renderer Integration

#### T6.0: MeshRenderer Visibility Integration ‚úÖ COMPLETED
**Atomic Functionality**: Ensure visibility changes reflect in rendering

**Status**: ‚úÖ COMPLETED (2025-10-03)
- MeshRenderingSystem::render() checks Visible component and skips rendering when visible=false
- SceneHierarchyPanel grays out invisible entities with ImGui color push/pop
- EntityInspectorPanel visibility checkbox creates ModifyVisibleCommand (verified existing)
- Multi-selection visibility changes work correctly (verified existing implementation)
- Undo/redo properly restores visibility state (verified via existing tests)
- 3 test cases in visibility_integration_tests.cpp - all passing
- Tests: `unit_test_runner.exe "[T6.0]"` or `"[visibility][integration]"`

**Files**:
- `src/runtime/mesh_rendering_system.cpp` (modified)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modified)
- `tests/visibility_integration_tests.cpp` (new)

**Implementation Steps** (completed):
1. ‚úÖ Added Visible component check in MeshRenderingSystem::render() loop
2. ‚úÖ Skip renderEntity() call when visible=false (early continue)
3. ‚úÖ Entities without Visible component default to visible (backward compatible)
4. ‚úÖ Added isInvisible lambda in SceneHierarchyPanel::renderEntityNode()
5. ‚úÖ Applied gray text color (0.5, 0.5, 0.5, 1.0) for invisible entities
6. ‚úÖ PopStyleColor() after TreeNodeEx() to restore default color
7. ‚úÖ Created comprehensive test suite (3 tests, 6 assertions)

**Test Cases** (all passing):
- ‚úÖ MeshRenderingSystem skips entities with visible=false
- ‚úÖ Entities without Visible component render normally
- ‚úÖ Entities with castShadows=false are processed (future integration documented)

**Acceptance** (achieved):
- ‚úÖ Visibility changes are immediate and reliable
- ‚úÖ Clear visual feedback in hierarchy panel (gray text)
- ‚úÖ No rendering artifacts or crashes
- ‚úÖ Selection outline rendering unaffected (can select invisible entities)

**Notes**:
- Minimal performance overhead: single component query with early exit
- Gray color provides clear visual distinction without being too subtle
- castShadows/receiveShadows flags documented for future shadow system
- Existing tests cover inspector visibility toggle and undo/redo
- No regressions: all mesh_rendering_system and scene_hierarchy tests pass

---

### Task 8: Object Creation and Asset Instantiation

**Overview**: This task completes the scene editing workflow by implementing the ability to add objects to existing scenes. Currently, users can only load entire scenes via File‚ÜíOpen, which replaces the whole scene. This task adds drag-and-drop asset instantiation, menu-based object creation, and proper asset-to-entity conversion commands.

**Current Gap**: T3.7 (Drag-and-Drop) implemented the drag **source** in Asset Browser but deferred drop **target** implementation. Users cannot currently add individual models/objects to an existing scene without replacing everything.

---

#### T8.1: CreateEntityFromAssetCommand Implementation
**Atomic Functionality**: Command for creating entities from asset files

**Status**: üî¥ NOT STARTED

**Files**:
- `src/editor/commands/EcsCommands.h` (modify - add new command)
- `src/editor/commands/EcsCommands.cpp` (modify - implement)
- `tests/ecs_command_tests.cpp` (modify - add tests)

**Implementation Steps**:
1. Add `CreateEntityFromAssetCommand` class to EcsCommands.h
2. Constructor takes: `Scene&`, `AssetManager&`, `assetPath`, `worldPosition`, `parentEntity` (optional)
3. Implement `execute()`:
   - Load asset via `AssetManager::load<assets::Scene>(assetPath)`
   - Use `SceneImporter::importScene()` to create entities from asset
   - Store created root entity for undo
   - Set world position on root entity's Transform
   - Set parent if specified
4. Implement `undo()`:
   - Destroy created entity hierarchy recursively
   - Restore scene state
5. Store component data for complete undo (Transform, MeshRenderer, Name, hierarchy)
6. Add `getDescription()` returning "Create entity from [filename]"
7. Handle load failures gracefully (return false, set error message)
8. Support both `.gltf` and `.glb` file formats

**Test Cases**:
- Command creates entity from valid .gltf asset
- Entity has correct Transform at specified position
- Entity has MeshRenderer with loaded mesh
- Entity has Name from asset file
- Undo removes created entity completely
- Load failure returns false without crashing
- Hierarchy from asset is preserved
- Parent assignment works correctly

**Acceptance**:
- Reliable entity creation from assets
- Full undo/redo support
- Handles all error cases gracefully
- Works with complex multi-node glTF files

---

#### T8.2: Viewport Drop Target Implementation
**Atomic Functionality**: Accept dropped assets in viewport to create entities

**Status**: üî¥ NOT STARTED

**Files**:
- `src/editor/viewport/viewport.cpp` (modify)
- `tests/viewport_tests.cpp` (modify - integration tests)

**Implementation Steps**:
1. Add drop target check in `Viewport::render()` after viewport ImGui::Image()
2. Use `ImGui::BeginDragDropTarget()` on viewport content region
3. Accept `"ASSET_BROWSER_ITEM"` payload type
4. Extract asset path from payload: `const char* assetPath = static_cast<const char*>(payload->Data)`
5. Calculate world position for entity placement:
   - Get mouse position in viewport: `ImGui::GetMousePos()`
   - Option A (Simple): Place at world origin (0, 0, 0)
   - Option B (Ray-cast): Calculate world position under cursor (see T8.4)
6. Create `CreateEntityFromAssetCommand` with path and position
7. Execute command via `CommandHistory::executeCommand()`
8. Provide visual feedback during drop (highlight drop area)
9. Show error message if asset load fails
10. Call `ImGui::EndDragDropTarget()`

**Test Cases**:
- Dropping .gltf on viewport creates entity
- Entity appears in scene at correct position
- Undo removes dropped entity
- Invalid assets show error message
- Drop area highlights during drag-over
- Works with viewport in different dock positions

**Acceptance**:
- Intuitive drag-and-drop workflow
- Immediate visual feedback
- Robust error handling
- Smooth integration with existing viewport

---

#### T8.3: Hierarchy Panel Drop Target Implementation
**Atomic Functionality**: Accept dropped assets in hierarchy to create child entities

**Status**: üî¥ NOT STARTED

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add drop target check in `renderEntityNode()` after tree node
2. Use `ImGui::BeginDragDropTarget()` on each entity tree node
3. Accept `"ASSET_BROWSER_ITEM"` payload type (in addition to existing "ENTITY_HIERARCHY")
4. Extract asset path from payload
5. Create `CreateEntityFromAssetCommand` with:
   - Asset path from payload
   - World position (0, 0, 0) - will be relative to parent
   - Parent entity set to drop target entity
6. Execute command via `CommandHistory::executeCommand()`
7. Visual feedback: highlight valid drop targets during drag
8. Show error message if asset load fails
9. Expand parent node to show newly created child

**Test Cases**:
- Dropping asset on entity creates child entity
- Child has correct parent-child relationship
- Transform is relative to parent
- Undo removes child entity
- Parent node expands to show new child
- Invalid assets show error message
- Works with deeply nested hierarchies

**Acceptance**:
- Easy to create hierarchies by dropping
- Clear visual feedback during drag
- Consistent with entity reparenting behavior
- Full undo/redo support

---

#### T8.4: World Position Ray-cast Calculation (Optional Enhancement)
**Atomic Functionality**: Calculate precise world position under mouse cursor

**Status**: üî¥ NOT STARTED (Optional)

**Files**:
- `src/editor/viewport/viewport.cpp` (modify)
- `engine/picking.h` (use existing ray-cast system)

**Implementation Steps**:
1. Add `calculateWorldPositionFromMouse(ImVec2 mousePos)` helper
2. Convert viewport mouse position to normalized device coordinates
3. Use camera to create ray from mouse position
4. Ray-cast against:
   - Option A: Ground plane (y=0 or configurable)
   - Option B: Existing scene geometry (using picking system)
   - Option C: Fixed distance from camera (e.g., 10 units)
5. Return intersection point as world position
6. If no intersection, use camera forward * fixed distance
7. Integrate into T8.2 viewport drop handling
8. Add visual indicator (ghost preview) at ray-cast position

**Test Cases**:
- Ray-cast finds correct position on ground plane
- Works with perspective and orthographic cameras
- Handles edge cases (looking at sky, extreme angles)
- Ghost preview shows at correct position
- Performance acceptable for real-time updates

**Acceptance**:
- Objects placed precisely under cursor
- Intuitive placement experience
- No performance impact during drag
- Works with all camera configurations

**Note**: Can be deferred - T8.2 can use origin placement initially.

---

#### T8.5: Create Menu Implementation
**Atomic Functionality**: Menu items for creating entities and primitives

**Status**: üî¥ NOT STARTED

**Files**:
- `src/editor/ui.cpp` (modify - add Create menu)
- `tests/ui_tests.cpp` (modify)

**Implementation Steps**:
1. Add "Create" menu to main menu bar (between Edit and View)
2. Add menu items:
   - **Create ‚Üí Empty Entity**: Creates entity with only Name and Transform
   - **Create ‚Üí Cube** (future): Creates entity with cube primitive mesh
   - **Create ‚Üí Sphere** (future): Creates entity with sphere primitive mesh
   - **Create ‚Üí Camera** (future): Creates entity with Camera component
   - **Create ‚Üí Light** (future): Creates entity with Light component
   - **Create ‚Üí From File...**: Opens file dialog to select .gltf/.glb
3. Wire "Empty Entity" to `CreateEntityCommand`
4. Wire "From File..." to file dialog + `CreateEntityFromAssetCommand`
5. Place new entities at:
   - World origin (0, 0, 0) by default
   - Or at camera forward position (e.g., 5 units ahead)
6. Add keyboard shortcuts:
   - `Ctrl+Shift+N`: Create Empty Entity
   - `Ctrl+Shift+I`: Create From File (Import)
7. Select newly created entity automatically
8. All operations go through CommandHistory for undo

**Test Cases**:
- Create Empty Entity creates entity with Name and Transform
- Create From File opens dialog and creates entity
- Keyboard shortcuts work correctly
- Created entities are automatically selected
- Undo removes created entities
- Menu items enable/disable appropriately

**Acceptance**:
- Standard editor workflow (like Unity/Unreal)
- Keyboard shortcuts accessible
- All operations undoable
- Clear menu organization

---

#### T8.6: Asset Loading Helper Functions
**Atomic Functionality**: Utility functions for loading single assets

**Status**: üî¥ NOT STARTED

**Files**:
- `src/runtime/scene_importer.h` (add helpers)
- `src/runtime/scene_importer.cpp` (implement)
- `tests/scene_importer_tests.cpp` (add tests)

**Implementation Steps**:
1. Add `loadSingleAsset(AssetManager&, path)` static method
2. Load .gltf/.glb file via AssetManager
3. Verify asset loaded successfully
4. Return `std::expected<std::shared_ptr<assets::Scene>, std::string>` for error handling
5. Add `createEntityFromAsset(Scene&, AssetManager&, assetPath, position, parent)` convenience method
6. Combines loading + importing in one call
7. Returns created root entity or error
8. Used by CreateEntityFromAssetCommand internally
9. Handle edge cases:
   - Empty scenes
   - Multi-root hierarchies
   - Assets without meshes (empty nodes)

**Test Cases**:
- loadSingleAsset loads valid .gltf file
- Returns error for non-existent files
- Returns error for invalid .gltf format
- createEntityFromAsset creates entity successfully
- Handles multi-node hierarchies correctly
- Returns error messages for failures

**Acceptance**:
- Clean API for asset loading
- Comprehensive error handling
- Reusable across commands and systems
- Well-tested edge cases

---

#### T8.7: Visual Feedback and Error Messages
**Atomic Functionality**: User feedback during asset operations

**Status**: üî¥ NOT STARTED

**Files**:
- `src/editor/viewport/viewport.cpp` (modify)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/ui.cpp` (modify)

**Implementation Steps**:
1. **Drag visual feedback**:
   - Highlight drop targets when dragging compatible assets
   - Show "+" cursor or green border for valid drop areas
   - Show "no" cursor or red border for invalid areas
2. **Ghost preview** (optional):
   - Render transparent preview of asset at drop position
   - Update position in real-time during drag
3. **Loading indicators**:
   - Show spinner/progress when loading large assets
   - "Creating entity..." message during import
4. **Error messages**:
   - Toast notification for failed asset loads
   - Specific messages: "File not found", "Invalid glTF format", "Unsupported asset type"
   - Actionable suggestions: "Check file path", "Verify file is valid glTF"
5. **Success feedback**:
   - Brief toast: "Created [entity name]"
   - Auto-select and frame new entity in viewport
6. Use consistent styling across all panels

**Test Cases**:
- Drop target highlights during valid drag
- Invalid drop areas show rejection visual
- Error messages appear for failed operations
- Success notifications are brief and clear
- Loading indicators show for >100ms operations

**Acceptance**:
- Clear visual feedback at all times
- Users understand what's happening
- Errors have actionable messages
- Professional polish

---

#### T8.8: Integration Testing and Documentation
**Atomic Functionality**: Comprehensive tests and user documentation

**Status**: üî¥ NOT STARTED

**Files**:
- `tests/object_creation_integration_tests.cpp` (new)
- `docs/adding_objects_guide.md` (new)
- `M2_P6.md` (update)

**Implementation Steps**:
1. **Integration Tests**:
   - Test complete drag-and-drop workflow: Browse ‚Üí Drag ‚Üí Drop ‚Üí Verify
   - Test Create menu workflow: Menu ‚Üí Select file ‚Üí Create ‚Üí Verify
   - Test undo/redo for all creation methods
   - Test multi-object creation (add 10 objects, verify all exist)
   - Test error handling (invalid files, missing assets)
   - Test hierarchy creation via hierarchy drop
   - Performance test: Add 100 objects, verify acceptable frame time
2. **Unit Tests**:
   - CreateEntityFromAssetCommand execute/undo/redo
   - Asset loading helpers
   - World position calculation
3. **Documentation**:
   - Write user guide: "How to Add Objects to Your Scene"
   - Document drag-and-drop workflow with screenshots
   - Document Create menu options
   - Document keyboard shortcuts
   - Add troubleshooting section for common issues
4. **Code Comments**:
   - Add XML comments to CreateEntityFromAssetCommand
   - Document drop target payload format
   - Comment ray-cast calculation logic

**Test Cases**:
- All integration tests pass
- Documentation is clear and accurate
- Screenshots show correct workflow
- Code is well-commented

**Acceptance**:
- >85% test coverage for new code
- Complete user-facing documentation
- Clear API documentation in code
- No regressions in existing functionality

---

### Task 8: Success Metrics

**Functional Completeness**:
- ‚úÖ Users can drag assets from browser to viewport/hierarchy
- ‚úÖ Users can create entities via Create menu
- ‚úÖ All creation methods support full undo/redo
- ‚úÖ Assets load reliably with clear error messages
- ‚úÖ Hierarchy relationships preserved during creation

**Performance**:
- ‚úÖ Asset loading <500ms for typical .gltf files
- ‚úÖ Entity creation <16ms (maintains 60fps)
- ‚úÖ Drag visual feedback updates at 60fps
- ‚úÖ No stuttering during asset instantiation

**Usability**:
- ‚úÖ Drag-and-drop feels natural and responsive
- ‚úÖ Clear visual feedback at all times
- ‚úÖ Error messages are helpful and actionable
- ‚úÖ Workflow matches industry standards (Unity/Unreal)

**Quality**:
- ‚úÖ No crashes with invalid assets
- ‚úÖ No memory leaks during repeated operations
- ‚úÖ Comprehensive test coverage
- ‚úÖ Complete documentation

---

### Task 8: Implementation Notes

**Integration with Existing Systems**:
- Uses `SceneImporter` from Phase 2 for asset loading
- Uses `CommandHistory` from Phase 5 for undo/redo
- Uses `SelectionManager` from Phase 3 for auto-selection
- Uses `picking::PickingSystem` for ray-cast (optional T8.4)
- Integrates with `AssetBrowserPanel` from T3.7

**Design Decisions**:
- **Command Pattern**: All creation goes through commands for consistency
- **Payload Format**: String path in drag-drop payload (simple, extensible)
- **World Position**: Start simple (origin), add ray-cast later
- **Error Handling**: Use `std::expected` for modern C++23 error handling
- **Loading Strategy**: Synchronous for MVP, async loading future enhancement

**Known Limitations**:
- Synchronous asset loading may block UI for large files (>10MB)
- No preview thumbnail during drag (text only)
- No "ghost preview" at drop location initially
- Single asset per drop (no multi-selection drag)

**Future Enhancements (Post-Task 8)**:
- Async asset loading with progress bar
- 3D thumbnail preview during drag
- Ghost preview showing final placement
- Multi-asset drag-and-drop
- Drag from external file explorer
- Asset favorites/recent for quick access
- Prefab system for reusable entity templates

---

### Task 8: Testing Strategy

**Unit Tests** (per task):
- T8.1: CreateEntityFromAssetCommand execution, undo, error handling
- T8.6: Asset loading helper functions, edge cases

**Integration Tests** (T8.8):
- Complete workflows (drag-drop, menu creation)
- Cross-system interactions (commands + assets + ECS)
- Error scenarios (missing files, corrupt assets)

**Manual Testing**:
- UI feel and responsiveness
- Visual feedback quality
- Error message clarity
- Workflow intuitiveness

**Performance Testing**:
- Asset loading time profiling
- Entity creation overhead
- Drag visual update frame rate
- Memory usage with many assets

---

### Task 8: Dependencies

**From Previous Phases**:
- Phase 2: `SceneImporter`, `AssetManager`, glTF loading
- Phase 3: `picking::PickingSystem` for ray-cast (T8.4)
- Phase 5: `CommandHistory`, `Command` base class
- Phase 6 T3.7: Asset Browser drag source

**External Libraries**:
- ImGui: Drag-drop API (`BeginDragDropTarget`, `AcceptDragDropPayload`)
- nlohmann/json: Asset metadata parsing
- cgltf: glTF file format support (already integrated)

---

### Task 8: Implementation Order

**Week 1** (Core functionality):
1. T8.1: CreateEntityFromAssetCommand (foundation)
2. T8.6: Asset loading helpers (used by T8.1)
3. T8.2: Viewport drop target (primary workflow)

**Week 2** (Alternative workflows):
4. T8.3: Hierarchy drop target (parenting workflow)
5. T8.5: Create menu (keyboard/menu workflow)

**Week 3** (Polish and optional):
6. T8.7: Visual feedback and error messages
7. T8.4: Ray-cast positioning (optional enhancement)
8. T8.8: Integration tests and documentation

---

### Task 8: Completion Criteria

Task 8 is complete when:

1. ‚úÖ CreateEntityFromAssetCommand implemented with full undo/redo
2. ‚úÖ Viewport accepts asset drops and creates entities
3. ‚úÖ Hierarchy accepts asset drops and creates child entities
4. ‚úÖ Create menu provides alternative creation methods
5. ‚úÖ Asset loading helpers are robust and well-tested
6. ‚úÖ Visual feedback is clear and responsive
7. ‚úÖ Error messages are helpful and actionable
8. ‚úÖ All tests pass (unit + integration)
9. ‚úÖ Documentation is complete
10. ‚úÖ Code review approved

---

### Task 7: Testing and Polish

#### T7.1: Comprehensive Integration Tests ‚úÖ COMPLETED (2025-01-19)
**Atomic Functionality**: Test complete workflows

**Status**: ‚úÖ Foundation complete - 3 test sections passing (Create, Save, Round-trip)

**Files**:
- `tests/scene_editor_integration_tests.cpp` (created)
- `src/runtime/scene_serialization/SceneSerializer.cpp` (bugfix: iterator invalidation)
- `src/runtime/ecs.h` (bugfix: getEntityCount() to count only valid entities)

**Implementation Steps**:
1. Create test: Load asset ‚Üí Create entity ‚Üí Transform ‚Üí Save ‚Üí Load
2. Verify scene state after each operation
3. Test: Multi-select ‚Üí Batch transform ‚Üí Undo all
4. Test: Drag-drop asset ‚Üí Rename ‚Üí Reparent ‚Üí Delete
5. Test: Create hierarchy ‚Üí Save ‚Üí Load ‚Üí Verify structure
6. Test: Fill scene with 1000 entities ‚Üí Check performance
7. Test: Rapid undo/redo 100 times ‚Üí Check stability

**Test Cases**:
- Complete editing workflows succeed
- Performance remains acceptable with large scenes
- Undo/redo handles complex scenarios
- No memory leaks in long sessions

**Acceptance**:
- All workflows work end-to-end
- Performance meets requirements
- Stability is rock-solid

---

#### T7.2: UI Polish and Usability
**Atomic Functionality**: Improve visual feedback and UX

**Files**:
- All panel implementation files

**Implementation Steps**:
1. Add tooltips to all buttons and controls
2. Add icons where appropriate (using ImGui icon fonts)
3. Improve spacing and padding in panels
4. Add visual separators between sections
5. Use colors consistently (selection, hover, active)
6. Add loading indicators for slow operations
7. Improve error messages with actionable suggestions

**Test Cases**:
- All interactive elements have tooltips
- UI feels responsive and polished
- Colors and spacing are consistent
- Error messages are helpful

**Acceptance**:
- Professional-looking UI
- Easy to learn and use
- Consistent with industry standards

---

#### T7.3: Performance Optimization
**Atomic Functionality**: Ensure smooth operation with large scenes

**Files**:
- All implementation files

**Implementation Steps**:
1. Profile hierarchy panel with 10,000 entities
2. Implement virtual scrolling if needed (ImGui clipper)
3. Cache entity lookups in panels
4. Batch component queries where possible
5. Profile inspector with complex entities
6. Optimize asset browser with many files
7. Add progress bars for slow operations

**Test Cases**:
- Hierarchy with 10,000 entities maintains 60fps
- Inspector updates smoothly during dragging
- Asset browser scrolls smoothly with 1000+ files
- No UI stuttering during complex operations

**Acceptance**:
- Smooth UI at all times
- Large scenes are usable
- No performance regressions

---

#### T7.4: Documentation and Examples
**Atomic Functionality**: Document usage and provide examples

**Files**:
- `docs/scene_editor_guide.md` (new)
- `docs/scene_format_spec.md` (new)
- `assets/examples/example_scene.json` (new)

**Implementation Steps**:
1. Write user guide for scene editor
2. Document all keyboard shortcuts
3. Document all menu commands
4. Write scene format specification
5. Create example scene files
6. Add code comments to public APIs
7. Create video/GIF demonstrations (optional)

**Test Cases**:
- Documentation covers all features
- Examples load successfully
- Instructions are clear and accurate

**Acceptance**:
- Complete documentation
- Easy to learn for new users
- Reference for all features

---

## üß™ Testing Strategy

### Unit Tests
Each task includes unit tests for:
- Panel rendering without errors
- Command creation and execution
- UI state management
- File I/O operations

### Integration Tests
- Complete editing workflows (T7.1)
- Cross-panel interactions
- Undo/redo across all operations
- Save/load round-trip verification
- Existing UI integration (no regressions)
- Viewport rendering updates from inspector changes
- Camera focus and navigation

### Performance Tests
- Large scene handling (10,000+ entities)
- Rapid command execution
- UI responsiveness under load
- Memory leak detection

### Manual Testing
- UI visual verification
- Interaction feel and polish
- Error message clarity
- Keyboard shortcut conflicts

---

## üìà Success Metrics

### Functional Completeness
- ‚úÖ All panels render and function correctly
- ‚úÖ All editing operations work through commands
- ‚úÖ Scene save/load is lossless
- ‚úÖ Multi-selection works across all panels
- ‚úÖ Drag-and-drop operations are intuitive

### Performance
- ‚úÖ 60fps UI with 1,000 entities
- ‚úÖ 30fps UI with 10,000 entities
- ‚úÖ < 100ms scene save/load for typical scenes
- ‚úÖ < 16ms input response time

### Quality
- ‚úÖ No crashes in normal operation
- ‚úÖ No memory leaks in extended sessions
- ‚úÖ Clear error messages for all failure cases
- ‚úÖ Comprehensive test coverage (>85%)

### Usability
- ‚úÖ Intuitive for users familiar with Unity/Unreal
- ‚úÖ All common operations accessible via keyboard
- ‚úÖ Clear visual feedback for all actions
- ‚úÖ Consistent UI/UX across all panels

---

## üöÄ Deliverables

1. **Scene Hierarchy Panel** - Complete tree view with drag-and-drop
2. **Entity Inspector Panel** - Component editing with undo/redo
3. **Asset Browser Panel** - File navigation and asset import
4. **Scene Editor** - Integrated editing environment
5. **Scene Serialization** - JSON save/load system
6. **Comprehensive Tests** - Unit, integration, and performance tests
7. **Documentation** - User guide and technical specs

---

## ‚å®Ô∏è Keyboard Shortcuts Reference

This section documents all keyboard shortcuts that should be implemented across the scene editor:

### Global Shortcuts
- **Ctrl+N**: New Scene
- **Ctrl+O**: Open Scene
- **Ctrl+S**: Save Scene
- **Ctrl+Shift+S**: Save Scene As
- **Ctrl+Z**: Undo
- **Ctrl+Y** or **Ctrl+Shift+Z**: Redo
- **Delete**: Delete selected entities
- **Ctrl+D**: Duplicate selected entities
- **F**: Frame selected entity in viewport
- **Escape**: Clear selection

### Gizmo Mode Shortcuts
- **W**: Translate mode
- **E**: Rotate mode  
- **R**: Scale mode
- **Q**: No gizmo

### Hierarchy Panel Shortcuts
- **F2**: Rename selected entity
- **Ctrl+C**: Copy entity (future)
- **Ctrl+V**: Paste entity (future)
- **Ctrl+X**: Cut entity (future)
- **Ctrl+A**: Select all entities (future)

### Inspector Panel Shortcuts
- **Ctrl+Click** on component header: Collapse/expand
- **Alt+Click** on vec3 component: Reset to default

### Asset Browser Shortcuts
- **Backspace**: Go up one directory level
- **Enter**: Open selected folder
- **Ctrl+F**: Focus search field (future)

---

## üìã Dependencies

### From Previous Phases
- **Phase 1**: ECS with hierarchy and components
  - `ecs::Scene` with entity management
  - `Scene::setParent()`, `getParent()`, `getChildren()` for hierarchy
  - Components: Transform, Name, Visible, MeshRenderer, Selected
- **Phase 2**: Asset pipeline with glTF loading
  - `assets::AssetManager` for asset management
  - `assets::MeshHandle` system
  - glTF import functionality
- **Phase 2.5**: GPU Resource Management
  - `engine::GPUResourceManager` for GPU resource caching
  - `engine::gpu::MeshGPU` for GPU mesh data
- **Phase 3**: Selection system with picking
  - `editor::SelectionManager` for selection tracking
  - `picking::PickingSystem` for ray-cast picking
- **Phase 4**: Gizmo system for transformations
  - `editor::GizmoSystem` for gizmo rendering and interaction
  - Transform gizmo modes (translate/rotate/scale)
- **Phase 5**: Command system with undo/redo
  - `CommandHistory` class for undo/redo stack
  - Existing commands: `CreateEntityCommand`, `DeleteEntityCommand`, `AddComponentCommand`, `RemoveComponentCommand`, `SetParentCommand`, `RenameEntityCommand`
  - `TransformEntityCommand` and `BatchTransformCommand` for gizmo integration
  - Command merging support for continuous operations

### New Commands for Phase 6
The following commands need to be implemented for Phase 6 functionality:

1. **DuplicateEntityCommand** (T1.5)
   - Duplicates entity with all components
   - Handles hierarchy recursion
   - Adjusts names and positions

2. **ModifyComponentCommand<T>** (T1.6, T2.3, T2.4)
   - Generic command for modifying any component
   - Stores old and new component state
   - Supports command merging for continuous edits

3. **CreateEntityFromAssetCommand** (T8.1) ‚≠ê NEW - HIGH PRIORITY
   - Creates entity from dragged/selected asset file
   - Loads mesh via AssetManager and assigns MeshRenderer
   - Positions entity at specified world location
   - Sets parent entity for hierarchy drops
   - Supports full undo with stored component data

4. **BatchModifyCommand** (T2.8)
   - Modifies same component on multiple entities
   - Used for multi-selection edits
   - Stores per-entity old/new states

These build upon the command infrastructure from Phase 5.

### External Libraries
- **ImGui**: Already integrated, used for all UI
- **nlohmann/json**: For scene serialization (add to vcpkg.json if not present)
- **std::filesystem**: For file system navigation (C++17 standard)

### Build System
- Update CMakeLists.txt to include new source directories:
  - `src/editor/scene_hierarchy/`
  - `src/editor/entity_inspector/`
  - `src/editor/asset_browser/`
  - `src/editor/scene_editor/`
  - `src/runtime/scene_serialization/`

---

## üîÑ Implementation Order

### Week 1: Foundation and Analysis
1. T4.0: Analyze existing UI class and plan integration
2. T1.1-T1.3: Basic hierarchy panel with selection
3. T2.1-T2.3: Inspector foundation with transform editing
4. T3.1-T3.3: Asset browser with navigation

### Week 2: Advanced Features
5. T1.4-T1.7: Hierarchy drag-and-drop, context menu, and camera focus
6. T2.4-T2.8: Complete inspector with all components and multi-selection
7. T3.4-T3.7: Asset browser with import and drag-drop

### Week 3: Integration, Rendering, and Polish
8. T4.1-T4.6: Scene editor integration with existing UI
9. T5.1-T5.4: Scene serialization
10. T6.0: Renderer integration and visibility
11. T7.1-T7.4: Testing, optimization, and documentation

### Week 4: Object Creation Workflow (NEW)
12. T8.1-T8.6: CreateEntityFromAssetCommand and drop targets
13. T8.7: Visual feedback and error messages
14. T8.4: Ray-cast positioning (optional)
15. T8.8: Integration tests and documentation

---

## üéØ Completion Criteria

Phase 6 is complete when:

1. ‚úÖ All three panels (hierarchy, inspector, asset browser) are functional
2. ‚úÖ Scene editor orchestrates all systems correctly
3. ‚úÖ Scene save/load works reliably
4. ‚úÖ All editing operations support undo/redo
5. ‚úÖ Multi-selection works consistently
6. ‚úÖ Drag-and-drop operations are smooth
7. ‚úÖ **Object creation workflow is complete (drag-drop + menu)** ‚≠ê NEW
8. ‚úÖ **Assets can be instantiated into existing scenes** ‚≠ê NEW
9. ‚úÖ Performance meets targets with large scenes
10. ‚úÖ All tests pass (unit, integration, performance)
11. ‚úÖ Documentation is complete and accurate
12. ‚úÖ Code review approval from team

---

## üìù Notes

### Design Decisions
- **Immediate Mode UI**: ImGui simplifies state management and integration
- **Command Pattern**: All edits go through commands for consistent undo/redo
- **JSON Format**: Human-readable and easy to version control
- **Modular Panels**: Each panel is independent and reusable

### Future Enhancements (Post-Phase 6)
- Asset thumbnails with 3D preview rendering
- Native file dialogs (Windows IFileDialog, platform-specific)
- Search and filter in hierarchy and asset browser
- Favorites/bookmarks in asset browser
- Prefab system for reusable entity templates
- Scene templates for quick start
- Collaborative editing (multi-user)

### Known Limitations
- No 3D asset preview (text-based preview only)
- No texture preview (future enhancement)
- Limited file operations (no cut/paste/duplicate for assets)
- Single scene per editor instance
- No real-time collaboration
- No auto-save functionality (should be added for safety)

### UI/UX Considerations

#### Color Scheme and Theming
- Use consistent ImGui colors for selection, hover, active states
- Selected entities: Orange/gold highlight
- Hovered entities: Subtle blue-gray highlight
- Modified values in inspector: Different color until saved
- Error states: Red text/background

#### Responsive Feedback
- Show loading spinners for long operations (>100ms)
- Disable UI elements during processing
- Show progress bars for batch operations
- Provide audio/visual feedback for errors
- Toast notifications for successful operations

#### Accessibility
- Tooltip on every interactive element (delay: 0.5s)
- Keyboard navigation support throughout
- Clear focus indicators
- Readable font sizes (minimum 12pt)
- Sufficient color contrast

#### Performance Targets
- Hierarchy update: <16ms for 1000 entities
- Inspector update: <5ms per frame
- Asset browser grid render: <16ms for 500 files
- Search/filter: <50ms for 10,000 entities

---

## üîó Related Documents

- **MILESTONE_2.md**: Overall milestone plan
- **M2_P1.md**: Enhanced ECS System
- **M2_P2.md**: glTF Asset Import Pipeline
- **M2_P3.md**: Object Picking & Selection System
- **M2_P4.md**: 3D Gizmo Manipulation System
- **M2_P5.md**: Undo/Redo Command Stack
- **PROGRESS_2.md**: Implementation progress tracking

---

**End of Phase 6 Implementation Plan**

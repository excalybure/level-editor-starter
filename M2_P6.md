# Milestone 2 - Phase 6: Scene Editing UI

## üìã Overview

**Phase**: 6 of 6  
**Duration**: Week 6-7 (2 weeks)  
**Dependencies**: Phases 1-5 (ECS, Assets, Picking, Gizmos, Commands)

**Goal**: Create a complete scene editing user interface with hierarchy panel, entity inspector, asset browser, and integrated scene editor. This phase ties together all previous systems into a cohesive editing experience.

---

## üéØ Objectives

1. Build scene hierarchy panel with tree view and drag-and-drop reparenting
2. Create entity inspector panel for component editing
3. Implement asset browser for importing and managing assets
4. Develop integrated scene editor orchestrating all panels
5. Add context menus and keyboard shortcuts for common operations
6. Implement scene save/load functionality
7. Support multi-selection across all UI panels

---

## üèóÔ∏è Architecture Overview

### Component Structure
```
src/editor/
‚îú‚îÄ‚îÄ scene_hierarchy/
‚îÇ   ‚îú‚îÄ‚îÄ SceneHierarchyPanel.h            # Tree view of entities
‚îÇ   ‚îî‚îÄ‚îÄ SceneHierarchyPanel.cpp
‚îú‚îÄ‚îÄ entity_inspector/
‚îÇ   ‚îú‚îÄ‚îÄ EntityInspectorPanel.h           # Component editing UI
‚îÇ   ‚îú‚îÄ‚îÄ EntityInspectorPanel.cpp
‚îÇ   ‚îú‚îÄ‚îÄ ComponentUI.h                    # UI helpers for components
‚îÇ   ‚îî‚îÄ‚îÄ ComponentUI.cpp
‚îú‚îÄ‚îÄ asset_browser/
‚îÇ   ‚îú‚îÄ‚îÄ AssetBrowserPanel.h              # Asset management UI
‚îÇ   ‚îî‚îÄ‚îÄ AssetBrowserPanel.cpp
‚îî‚îÄ‚îÄ scene_editor/
    ‚îú‚îÄ‚îÄ SceneEditor.h                    # Main orchestrator
    ‚îî‚îÄ‚îÄ SceneEditor.cpp
```

### Integration Points
- **Selection System**: All panels interact with `SelectionManager`
- **Command System**: All edits go through `CommandHistory` for undo/redo
- **Gizmo System**: Inspector and hierarchy trigger gizmo operations
- **Asset Pipeline**: Asset browser integrates with `AssetManager`
- **ECS**: All panels read/write to `ecs::Scene`
- **Existing UI Class**: Panels should integrate with existing `editor::UI` class which already manages:
  - Viewport system and ViewportManager
  - Grid and camera settings windows
  - Gizmo tools and settings windows
  - Command history window
  - File operations (loadScene, clearScene)
  - Main menu bar and docking layout

### Hierarchy Implementation Note
- The ECS uses **implicit hierarchy** via `Scene::setParent()`, `Scene::getParent()`, and `Scene::getChildren()` methods
- No explicit `Hierarchy` component exists - parent/child relationships are stored in Scene's internal maps
- UI panels access hierarchy through Scene methods, not through component queries

---

## üì¶ Task Breakdown

### Task 1: Scene Hierarchy Panel Foundation

#### T1.1: Basic Tree View Rendering
**Atomic Functionality**: Display flat list of entities

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.h` (new)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (new)
- `tests/scene_hierarchy_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `SceneHierarchyPanel` class
2. Add constructor taking `Scene&`, `SelectionManager&`, `CommandHistory&`
3. Implement `render()` method with ImGui window
4. Add `renderEntityTree()` to iterate over all entities
5. Display entity names using `components::Name`
6. Handle entities without name component (show "Entity [ID]")

**Test Cases**:
- Empty scene renders without errors
- Scene with entities displays all entity names
- Entities without name show ID fallback
- Panel can be hidden/shown via `setVisible()`

**Acceptance**:
- Tree view displays all entities in scene
- Entity names are readable and formatted
- No crashes with empty or malformed scenes

---

#### T1.2: Hierarchical Tree Structure
**Atomic Functionality**: Display parent-child relationships

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.h` (modify)
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderEntityNode(Entity, bool isRoot)` for recursive rendering
2. Use ImGui tree nodes for hierarchical display
3. Query Scene's hierarchy methods: `scene.getParent(entity)` and `scene.getChildren(entity)`
   - Note: No `Hierarchy` component exists; use Scene's hierarchy API directly
4. Indent child entities appropriately
5. Add expand/collapse functionality (ImGui built-in)
6. Display hierarchy icons (parent/child indicators)

**Test Cases**:
- Root entities display at top level
- Child entities are indented under parents
- Deep hierarchies (5+ levels) render correctly
- Expand/collapse state persists during frame

**Acceptance**:
- Clear visual hierarchy with indentation
- Tree nodes expand/collapse smoothly
- Deep hierarchies are navigable

---

#### T1.3: Selection Integration
**Atomic Functionality**: Clicking entity selects it

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Check `ImGui::IsItemClicked()` on each entity node
2. Call `SelectionManager::select()` on click
3. Support Ctrl+Click for multi-selection
4. Support Shift+Click for range selection
5. Highlight selected entities with different color
6. Query `SelectionManager::isSelected()` for rendering

**Test Cases**:
- Single click selects entity
- Ctrl+Click adds/removes from selection
- Shift+Click selects range
- Selected entities highlight correctly
- Selection synchronizes with other systems

**Acceptance**:
- Intuitive selection behavior matching standard UIs
- Multi-selection works correctly
- Visual feedback is clear

---

#### T1.4: Drag-and-Drop Reparenting
**Atomic Functionality**: Drag entity onto another to change parent

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/commands/HierarchyCommands.h` (new)
- `src/editor/commands/HierarchyCommands.cpp` (new)
- `tests/scene_hierarchy_tests.cpp` (modify)
- `tests/hierarchy_command_tests.cpp` (new)

**Implementation Steps**:
1. Add `m_draggedEntity` member variable
2. Use `ImGui::BeginDragDropSource()` on entity nodes
3. Set payload with entity ID
4. Use `ImGui::BeginDragDropTarget()` on target nodes
5. Create `ReparentEntityCommand` class
6. Implement `execute()` and `undo()` for reparenting
   - Use `scene.setParent(entity, newParent)` to update hierarchy
   - Store old parent for undo operation
7. Push command to `CommandHistory` on drop
8. Verify circular reference prevention (cannot parent to descendant)

**Test Cases**:
- Dragging entity changes parent
- Cannot drag entity onto itself
- Cannot drag parent onto its own child (circular)
- Undo/redo restores previous parent
- World transform remains constant during reparent

**Acceptance**:
- Drag-and-drop feels natural and responsive
- Circular references prevented
- Undo/redo works correctly
- World positions preserved

---

#### T1.5: Context Menu
**Atomic Functionality**: Right-click shows entity operations

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance from Phase 5)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderContextMenu(Entity)` method
2. Check `ImGui::IsItemClicked(ImGuiMouseButton_Right)`
3. Open popup with `ImGui::OpenPopup("EntityContextMenu")`
4. Add menu items:
   - Create Child Entity
   - Duplicate (copies entity and all components)
   - Delete (with confirmation dialog for entities with children)
   - Rename (triggers inline editing)
   - Copy (future: copy to clipboard)
   - Paste (future: paste from clipboard)
5. Wire menu items to existing commands from Phase 5:
   - Use `CreateEntityCommand` for Create Child
   - Use `DeleteEntityCommand` for Delete
   - Use `RenameEntityCommand` for Rename
6. Implement `DuplicateEntityCommand` that:
   - Creates new entity
   - Copies all components from source
   - Adjusts name (append " Copy")
   - Preserves hierarchy if duplicating with children (recursive)
   - Positions near original (slight offset)
7. Show different menu for empty space (Create Root Entity)

**Test Cases**:
- Right-click opens context menu
- Create Child adds child entity
- Duplicate clones entity with components
- Delete removes entity (with confirmation)
- Rename initiates inline editing

**Acceptance**:
- Context menu appears near cursor
- All operations work as expected
- Menu closes after action

---

#### T1.6: Inline Rename
**Atomic Functionality**: Double-click entity to rename

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/commands/ComponentCommands.h` (new)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add `m_renameEntity` and `m_renameBuffer` members
2. Check `ImGui::IsItemHovered() && ImGui::IsMouseDoubleClicked()`
3. Switch to `ImGui::InputText()` for editing
4. Create `ModifyComponentCommand<Name>` generic command
5. Submit command on Enter or lost focus
6. Cancel on Escape key

**Test Cases**:
- Double-click starts rename mode
- Enter confirms new name
- Escape cancels rename
- Lost focus confirms name
- Undo/redo restores previous name

**Acceptance**:
- Rename feels intuitive and responsive
- Command system captures all name changes
- No duplicate names allowed (optional validation)

---

#### T1.7: Focus Selected Entity (Frame in View)
**Atomic Functionality**: Double-click entity to focus camera on it

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `src/editor/viewport/viewport.h` (check API)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Detect double-click on entity node (F key shortcut alternative)
2. Calculate entity's world-space bounding box
   - Use Transform component world position
   - If MeshRenderer present, use bounds
   - Otherwise, use default size
3. Access active viewport's camera controller
4. Call camera focus/frame function with bounding box
5. Add "Frame Selected" menu item to context menu
6. Add keyboard shortcut (F key) when entity selected

**Test Cases**:
- Double-click centers camera on entity
- F key focuses on selected entity
- Works with entities without mesh (uses position only)
- Works with large/small entities (appropriate zoom)
- Context menu "Frame Selected" works

**Acceptance**:
- Quick navigation to entities in large scenes
- Camera framing is intuitive and useful
- Works across all viewport types

---

#### T1.8: Search and Filter
**Atomic Functionality**: Filter entities by name in hierarchy

**Files**:
- `src/editor/scene_hierarchy/SceneHierarchyPanel.cpp` (modify)
- `tests/scene_hierarchy_tests.cpp` (modify)

**Implementation Steps**:
1. Add search input field at top of hierarchy panel
2. Add `m_searchFilter` string member
3. Filter entity display based on search string
4. Support case-insensitive search
5. Highlight matching entities
6. Optionally expand parent nodes to show matches
7. Show "X of Y entities" count when filtering
8. Add clear button (X) to search field

**Test Cases**:
- Empty search shows all entities
- Search filters by entity name
- Case-insensitive matching works
- Parent nodes expand to show matches
- Clear button resets filter

**Acceptance**:
- Fast search even with 1000+ entities
- Intuitive filtering behavior
- Clear indication of filtered state

---

### Task 2: Entity Inspector Panel

#### T2.1: Inspector Panel Foundation
**Atomic Functionality**: Display selected entity info

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.h` (new)
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (new)
- `tests/entity_inspector_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `EntityInspectorPanel` class
2. Add constructor taking same dependencies as hierarchy panel
3. Implement `render()` with ImGui window
4. Check `SelectionManager::getSelectedEntities()`
5. Show "No Selection" message if empty
6. Show "Multiple Selected" if more than one
7. Add `renderEntityHeader(Entity)` for entity info

**Test Cases**:
- No selection shows appropriate message
- Single selection shows entity header
- Multi-selection shows count
- Panel can be hidden/shown

**Acceptance**:
- Inspector displays for selected entity
- Clear messaging for edge cases
- Clean UI layout

---

#### T2.2: Component UI Helpers
**Atomic Functionality**: Reusable UI widgets for component editing

**Files**:
- `src/editor/entity_inspector/ComponentUI.h` (new)
- `src/editor/entity_inspector/ComponentUI.cpp` (new)
- `tests/component_ui_tests.cpp` (new)

**Implementation Steps**:
1. Create `ComponentUI` utility class with static methods
2. Add `renderVec3Control(label, Vec3&, resetValue, speed)`
3. Use `ImGui::DragFloat3()` with custom formatting
4. Add reset button (right-click or dedicated button)
5. Add `renderFloatControl(label, float&, min, max)`
6. Use color coding for X/Y/Z axes (red/green/blue)
7. Return `bool` indicating if value changed

**Test Cases**:
- Vec3 control allows editing all components
- Reset button restores default value
- Color coding is visible and clear
- Float control respects min/max bounds

**Acceptance**:
- Intuitive drag-to-edit behavior
- Visual feedback for value changes
- Consistent styling across all controls

---

#### T2.3: Transform Component Editor
**Atomic Functionality**: Edit entity position, rotation, scale

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/entity_inspector/ComponentUI.cpp` (modify)
- `src/editor/commands/ComponentCommands.h` (enhance)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderTransformComponent(Entity)` method
2. Get `Transform` component from entity
3. Use `ComponentUI::renderVec3Control()` for position, rotation, scale
4. Create `ModifyTransformCommand` if value changed
5. Support command merging for continuous dragging
6. Show local vs world toggle (future enhancement placeholder)
7. Format rotation as degrees (convert from radians internally)

**Test Cases**:
- Position drag updates entity transform
- Rotation shows in degrees
- Scale affects all axes or individual
- Undo/redo restores previous transform
- Commands merge during continuous drag

**Acceptance**:
- Smooth editing experience
- Values update in real-time
- Undo/redo works perfectly
- Changes reflect in viewport immediately

---

#### T2.4: Name and Visible Component Editors
**Atomic Functionality**: Edit entity name and visibility

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/entity_inspector/ComponentUI.cpp` (modify)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `ComponentUI::renderName(Name&)`
2. Use `ImGui::InputText()` for name editing
3. Create command on text change
4. Add `ComponentUI::renderVisible(Visible&)`
5. Use `ImGui::Checkbox()` for visibility toggle
6. Create command on state change

**Test Cases**:
- Name input updates entity name
- Visibility checkbox toggles visibility
- Commands support undo/redo
- Changes propagate to hierarchy panel

**Acceptance**:
- Text input feels responsive
- Checkbox is clear and obvious
- All changes are undoable

---

#### T2.5: MeshRenderer Component Editor
**Atomic Functionality**: Edit mesh and material references

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/entity_inspector/ComponentUI.cpp` (modify)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `ComponentUI::renderMeshRenderer(MeshRenderer&, AssetManager&)`
2. Display mesh information:
   - Show mesh handle or "None" if no mesh
   - Display number of primitives if mesh is loaded
   - Show GPU resource status (loaded/not loaded)
3. Add "Browse" button to open asset selector (future)
4. For now, show read-only information
5. Display local bounding box dimensions
6. Show LOD bias slider (editable)
7. Future: Show material overrides per primitive (requires primitive-level editing)
8. Note: Actual mesh/material assignment should create commands for undo/redo

**Test Cases**:
- Mesh path displays correctly
- Primitive list shows all primitives
- Material overrides display for each primitive
- Future: Changing values creates commands

**Acceptance**:
- Clear display of mesh structure
- Primitive-based architecture is visible
- Foundation for future asset selector

---

#### T2.6: Add Component Menu
**Atomic Functionality**: Add new components to entity

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderAddComponentButton(Entity)` method
2. Show "Add Component" button at bottom of inspector
3. Open popup menu with component types
4. List available components:
   - Transform (note: usually auto-added)
   - MeshRenderer
   - Visible
   - Selected (editor component)
   - Future: Custom components
5. Create `AddComponentCommand<T>` generic command
6. Disable already-present components in menu
7. Initialize new components with default values

**Test Cases**:
- Button shows component type menu
- Adding component succeeds
- Duplicate components are disabled
- Undo removes the component
- New component appears in inspector

**Acceptance**:
- Easy to discover available components
- Clear which components are already present
- Commands work correctly

---

#### T2.7: Remove Component Menu
**Atomic Functionality**: Remove components from entity

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderComponentContextMenu(Entity, componentType)` method
2. Add small "‚ãÆ" button next to each component header
3. Open popup with "Remove Component" option
4. Create `RemoveComponentCommand<T>` generic command
5. Store component data for undo
6. Prevent removing essential components (Name, Transform)

**Test Cases**:
- Context menu appears on button click
- Removing component succeeds
- Essential components cannot be removed
- Undo restores component with original data
- Component disappears from inspector

**Acceptance**:
- Clear affordance for removal
- Safeguards against breaking entity
- Full undo/redo support

---

#### T2.8: Multi-Selection Support
**Atomic Functionality**: Show common properties for multiple entities

**Files**:
- `src/editor/entity_inspector/EntityInspectorPanel.cpp` (modify)
- `tests/entity_inspector_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderMultiSelectionInfo()` method
2. Show count of selected entities
3. List common components shared by all
4. Show "‚Äî" for properties with different values
5. Editing common property affects all entities
6. Create batch commands for multi-entity edits
7. Disable add/remove component for multi-selection

**Test Cases**:
- Multi-selection shows entity count
- Common properties are editable
- Different values show placeholder
- Batch command affects all selected
- Undo/redo works for batch operations

**Acceptance**:
- Intuitive behavior for multi-selection
- Clear indication of common vs different properties
- Batch operations feel snappy

---

### Task 3: Asset Browser Panel

#### T3.1: Basic File System Navigation
**Atomic Functionality**: Display directory contents

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.h` (new)
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (new)
- `tests/asset_browser_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `AssetBrowserPanel` class
2. Add constructor taking `AssetManager&`, `Scene&`, `CommandHistory&`
3. Implement `render()` with ImGui window
4. Add `m_rootPath` and `m_currentPath` members
5. Use `std::filesystem` to enumerate directories
6. Add `getDirectoryContents(path)` helper
7. Add `isDirectory(path)` helper
8. Display directories and files in list

**Test Cases**:
- Root directory displays correctly
- Subdirectories are recognized
- Files show appropriate icons/names
- Empty directories show message

**Acceptance**:
- Clear file system representation
- Directories and files distinguishable
- No crashes with invalid paths

---

#### T3.2: Directory Tree View
**Atomic Functionality**: Navigate folder hierarchy

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderDirectoryTree()` method
2. Use ImGui tree nodes for folders
3. Implement recursive folder traversal
4. Clicking folder sets `m_currentPath`
5. Highlight current directory
6. Add expand/collapse functionality

**Test Cases**:
- Folder tree displays hierarchy
- Clicking folder updates content view
- Current folder is highlighted
- Deep hierarchies are navigable

**Acceptance**:
- Standard tree navigation behavior
- Quick folder switching
- Clear visual feedback

---

#### T3.3: Path Breadcrumbs
**Atomic Functionality**: Show and navigate current path

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderPathBar()` method
2. Split current path into segments
3. Render each segment as clickable button
4. Use "/" or ">" as separator
5. Clicking segment navigates to that level
6. Add "Up One Level" button

**Test Cases**:
- Path displays all segments
- Clicking segment navigates correctly
- Up button goes to parent directory
- Root directory shows special icon

**Acceptance**:
- Easy navigation to any parent folder
- Clear indication of current location
- Matches standard file browser UX

---

#### T3.4: Asset Grid View
**Atomic Functionality**: Display assets as thumbnails

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderAssetGrid()` method
2. Use `ImGui::BeginChild()` for scrollable region
3. Arrange assets in grid layout (4-6 columns)
4. Show file icon based on type (mesh, material, texture)
5. Display filename below icon
6. Add `getAssetTypeFromExtension()` helper
7. Support .gltf, .glb, .obj for meshes (focus on .gltf)

**Test Cases**:
- Assets display in grid layout
- File types show correct icons
- Scrolling works with many assets
- Grid resizes with window

**Acceptance**:
- Clean, browsable asset view
- File types easily identifiable
- Responsive layout

---

#### T3.5: Asset Selection and Preview
**Atomic Functionality**: Select asset to see details

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add `m_selectedAsset` member
2. Highlight selected asset in grid
3. Add `renderAssetPreview(assetPath)` method
4. Show preview panel on right side (or bottom)
5. Display asset metadata (size, type, date)
6. For now, show text information
7. Future: Add 3D thumbnail preview

**Test Cases**:
- Clicking asset selects it
- Selection highlights correctly
- Preview shows asset information
- Double-click (future) opens asset

**Acceptance**:
- Clear selection feedback
- Useful metadata display
- Foundation for preview system

---

#### T3.6: Asset Import
**Atomic Functionality**: Import new assets into project

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add "Import Asset" button to toolbar
2. Add `importAsset(filePath)` method
3. Use native file dialog (Windows: `IFileDialog`, placeholder for now)
4. For now, use ImGui file dialog or text input
5. Call `AssetManager::importGLTF()` for supported files
6. Copy file to assets directory
7. Refresh directory view after import

**Test Cases**:
- Import button opens dialog (mocked)
- Valid files import successfully
- Asset appears in browser after import
- Invalid files show error message

**Acceptance**:
- Simple import workflow
- Error handling for invalid files
- Assets immediately available

---

#### T3.7: Drag-and-Drop to Scene
**Atomic Functionality**: Drag asset from browser to scene

**Files**:
- `src/editor/asset_browser/AssetBrowserPanel.cpp` (modify)
- `src/editor/commands/EcsCommands.h` (enhance)
- `tests/asset_browser_tests.cpp` (modify)

**Implementation Steps**:
1. Add `handleAssetDragDrop()` method
2. Use `ImGui::BeginDragDropSource()` on asset items
3. Set payload with asset path
4. Handle drop in viewport or hierarchy panel
5. Create `CreateEntityFromAssetCommand`
6. Load asset and create entity with MeshRenderer
7. Position at world origin or ray-cast hit point

**Test Cases**:
- Dragging asset shows drag visual
- Dropping in viewport creates entity
- Dropping in hierarchy creates under target
- Entity has correct mesh and components
- Undo removes created entity

**Acceptance**:
- Intuitive drag-and-drop workflow
- Quick scene population
- Full undo support

---

### Task 4: Scene Editor Integration

#### T4.0: Existing UI Class Analysis and Refactoring
**Atomic Functionality**: Understand and refactor existing UI integration points

**Files**:
- `src/editor/ui.h` (analyze)
- `src/editor/ui.cpp` (analyze)
- Review existing integration patterns

**Implementation Steps**:
1. Review existing `UI` class structure and responsibilities
2. Identify what functionality already exists (file loading, menu bar, docking)
3. Plan integration approach: extend UI class vs separate SceneEditor orchestrator
4. Document public API that panels will need from UI
5. Consider whether SceneEditor should be a member of UI or UI should create panels directly
6. Review existing `Impl` pattern used by UI class
7. Decide on ownership model for panels (UI owns vs SceneEditor owns)

**Design Decisions Required**:
- **Option A**: Add panel members directly to `UI` class and render them in UI::endFrame()
- **Option B**: Create `SceneEditor` class that UI owns and delegates panel management to
- **Option C**: Panels are independent and UI just provides layout/docking coordination

**Test Cases**:
- N/A - This is an analysis and design task

**Acceptance**:
- Clear integration strategy documented
- No conflicts with existing UI functionality
- Plan for maintaining existing features while adding new panels

---

#### T4.1: Scene Editor Foundation
**Atomic Functionality**: Orchestrate all panels

**Files**:
- `src/editor/scene_editor/SceneEditor.h` (new)
- `src/editor/scene_editor/SceneEditor.cpp` (new)
- `tests/scene_editor_tests.cpp` (new)

**Implementation Steps**:
1. Create header file with `SceneEditor` class
2. Add members for all panels and systems
3. Implement `initialize()` to create panels
4. Instantiate `SelectionManager`, `CommandHistory`
5. Create panel instances with shared dependencies
6. Implement `shutdown()` for cleanup
7. Add `update(deltaTime)` for per-frame logic

**Test Cases**:
- Editor initializes without errors
- All panels are created
- Shutdown cleans up properly
- No memory leaks

**Acceptance**:
- Clean initialization/shutdown
- All systems interconnected
- Ready for UI rendering

---

#### T4.2: Main Menu Bar Enhancement
**Atomic Functionality**: Extend existing menu with scene editing operations

**Files**:
- `src/editor/ui.cpp` (modify existing menu bar)
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Review existing menu bar in `UI::renderMainMenuBar()` (if it exists)
2. Add "Scene" or "Edit" menu section for scene operations
3. Add menu items: Create Entity, Delete Entity, Duplicate
4. Add "View" menu section with panel toggles:
   - Show/Hide Scene Hierarchy
   - Show/Hide Entity Inspector
   - Show/Hide Asset Browser
5. Wire "Edit" menu to command history (Undo/Redo)
6. Add "Create" menu with entity primitives and empty entity
7. Ensure menu items enable/disable based on selection state
8. Integrate with existing file operations (New Scene, Open, Save, Save As)

**Test Cases**:
- Menu bar displays correctly
- All menu items are clickable
- Keyboard shortcuts work (Ctrl+N, Ctrl+S, etc.)
- Menu items enable/disable appropriately

**Acceptance**:
- Standard menu bar UX
- All common operations accessible
- Keyboard shortcuts functional

---

#### T4.3: Input Handling
**Atomic Functionality**: Route input to appropriate systems

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Implement `handleKeyboardInput()` method
2. Check `ImGui::GetIO().WantCaptureKeyboard`
3. Route keys to command history (Ctrl+Z, Ctrl+Y)
4. Route keys to selection (Delete for entities)
5. Route keys to gizmo system (W/E/R for modes)
6. Implement `handleMouseInput()` method
7. Check `ImGui::GetIO().WantCaptureMouse`
8. Route clicks to picking system if not over UI

**Test Cases**:
- Ctrl+Z triggers undo
- Ctrl+Y triggers redo
- Delete removes selected entities
- W/E/R switches gizmo modes
- Mouse input ignored when over UI

**Acceptance**:
- Responsive keyboard controls
- No input conflicts with UI
- Standard editor shortcuts work

---

#### T4.4: Panel Layout and Docking
**Atomic Functionality**: Arrange panels in window

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Add `setupUI()` method called in `render()`
2. Use `ImGui::DockSpaceOverViewport()` for docking
3. Define default layout on first run
4. Hierarchy panel on left (20% width)
5. Inspector panel on right (25% width)
6. Asset browser on bottom (30% height)
7. Viewport in center (remaining space)
8. Save/load layout with `ImGui::SaveIniSettingsToDisk()`

**Test Cases**:
- Default layout is sensible
- Panels can be dragged and docked
- Layout persists across sessions
- Reset layout menu item works

**Acceptance**:
- Professional editor layout
- Flexible panel arrangement
- User customization supported

---

#### T4.5: Status Bar
**Atomic Functionality**: Show editor state information

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Add `renderStatusBar()` method
2. Use `ImGui::BeginViewportSideBar()` at bottom
3. Show entity count, selection count
4. Show command history position (undo stack depth)
5. Show current gizmo mode and space
6. Show frame time and FPS
7. Add separator between sections

**Test Cases**:
- Status bar displays at bottom
- All information updates in real-time
- Counts are accurate
- Performance metrics are readable

**Acceptance**:
- Useful at-a-glance information
- Unobtrusive placement
- Clear formatting

---

#### T4.6: Scene Modified Tracking
**Atomic Functionality**: Track unsaved changes

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Add `m_sceneModified` flag
2. Set flag when any command executes
3. Clear flag on save
4. Add asterisk to window title when modified
5. Add `handleSceneModification()` helper
6. Show warning dialog on New/Open with unsaved changes
7. Offer Save/Don't Save/Cancel options

**Test Cases**:
- Flag sets on entity modification
- Flag clears on save
- Window title shows asterisk
- Warning appears when appropriate
- User can cancel dangerous operations

**Acceptance**:
- No accidental data loss
- Clear indication of unsaved work
- Standard save prompt behavior

---

### Task 5: Scene Serialization

#### T5.1: Scene Save Format Design
**Atomic Functionality**: Define JSON schema for scenes

**Files**:
- `docs/scene_format.md` (new documentation)
- `src/runtime/scene_serialization/SceneSerializer.h` (new)
- `tests/scene_serialization_tests.cpp` (new)

**Implementation Steps**:
1. Design JSON schema for scene data
2. Include entities array with components
3. Store transform as position, rotation, scale
4. Store hierarchy as parent entity IDs
5. Store mesh renderer as asset paths
6. Include scene metadata (name, version)
7. Create example scene JSON for reference

**Example Schema**:
```json
{
  "version": "1.0",
  "name": "My Scene",
  "entities": [
    {
      "id": 1,
      "name": "Camera",
      "components": {
        "transform": {
          "position": [0, 5, -10],
          "rotation": [0.2, 0, 0, 0.98],
          "scale": [1, 1, 1]
        }
      }
    },
    {
      "id": 2,
      "name": "Cube",
      "parent": null,
      "components": {
        "transform": { "position": [0, 0, 0], "rotation": [0, 0, 0, 1], "scale": [1, 1, 1] },
        "meshRenderer": {
          "meshPath": "assets/models/cube.gltf",
          "materialOverrides": []
        },
        "visible": true
      }
    }
  ]
}
```

**Test Cases**:
- Schema covers all component types
- JSON is human-readable
- Handles entity references correctly
- Backward compatible (version field)

**Acceptance**:
- Complete scene representation
- Easy to parse and generate
- Extensible for future components

---

#### T5.2: Scene Save Implementation
**Atomic Functionality**: Serialize scene to JSON file

**Files**:
- `src/runtime/scene_serialization/SceneSerializer.cpp` (new)
- `tests/scene_serialization_tests.cpp` (modify)

**Implementation Steps**:
1. Create `SceneSerializer` class with static methods
2. Add `saveScene(Scene&, filepath)` method
3. Use nlohmann/json (add to vcpkg.json if needed)
4. Iterate all entities and serialize components
5. Handle entity ID to index mapping
6. Serialize parent references correctly
7. Write formatted JSON to file
8. Add error handling for file I/O

**Test Cases**:
- Empty scene saves successfully
- Scene with entities serializes all components
- Hierarchy relationships are preserved
- Save/load round-trip is lossless
- Invalid paths return errors

**Acceptance**:
- Reliable scene saving
- Human-readable output
- Error messages are helpful

---

#### T5.3: Scene Load Implementation
**Atomic Functionality**: Deserialize scene from JSON file

**Files**:
- `src/runtime/scene_serialization/SceneSerializer.cpp` (modify)
- `tests/scene_serialization_tests.cpp` (modify)

**Implementation Steps**:
1. Add `loadScene(Scene&, filepath)` method
2. Parse JSON file with error handling
3. Clear existing scene entities (with confirmation)
4. Create entities from JSON array
5. Map old entity IDs to new entities
6. Restore all components with data
7. Rebuild hierarchy relationships
8. Load referenced assets via AssetManager

**Test Cases**:
- Valid scene file loads successfully
- Invalid JSON shows error message
- Entity IDs are remapped correctly
- Hierarchy is reconstructed
- Assets are loaded automatically

**Acceptance**:
- Reliable scene loading
- Robust error handling
- Assets load on demand

---

#### T5.4: Scene Editor Save/Load Integration
**Atomic Functionality**: Wire serialization to editor UI

**Files**:
- `src/editor/scene_editor/SceneEditor.cpp` (modify)
- `tests/scene_editor_tests.cpp` (modify)

**Implementation Steps**:
1. Implement `newScene()` method
2. Show confirmation if scene modified
3. Clear scene and reset state
4. Implement `saveScene(filepath)` method
5. Call `SceneSerializer::saveScene()`
6. Update `m_currentScenePath` and `m_sceneModified`
7. Implement `loadScene(filepath)` method
8. Call `SceneSerializer::loadScene()`
9. Wire to File menu items

**Test Cases**:
- New scene clears editor
- Save creates file on disk
- Load populates scene
- File paths track correctly
- Modified flag updates appropriately

**Acceptance**:
- Complete save/load workflow
- Integrated with menu system
- User-friendly file dialogs

---

### Task 6: Renderer Integration

#### T6.0: MeshRenderer Visibility Integration
**Atomic Functionality**: Ensure visibility changes reflect in rendering

**Files**:
- `src/runtime/systems.h` (check existing VisibilitySystem)
- `src/editor/entity_inspector/ComponentUI.cpp` (enhance)
- `tests/visibility_integration_tests.cpp` (new)

**Implementation Steps**:
1. Verify that changing `Visible` component updates rendering
2. Ensure inspector changes are immediately visible in viewport
3. Test interaction with selection outline rendering
4. Add visual feedback in hierarchy for invisible entities (gray out)
5. Test batch visibility changes for multi-selection
6. Ensure command undo/redo properly refreshes rendering

**Test Cases**:
- Toggle visibility updates viewport rendering
- Hidden entities don't render but can still be selected
- Hierarchy shows visual distinction for hidden entities
- Undo visibility change restores rendering state

**Acceptance**:
- Visibility changes are immediate and reliable
- Clear visual feedback in all panels
- No rendering artifacts

---

### Task 7: Testing and Polish

#### T7.1: Comprehensive Integration Tests
**Atomic Functionality**: Test complete workflows

**Files**:
- `tests/scene_editor_integration_tests.cpp` (new)

**Implementation Steps**:
1. Create test: Load asset ‚Üí Create entity ‚Üí Transform ‚Üí Save ‚Üí Load
2. Verify scene state after each operation
3. Test: Multi-select ‚Üí Batch transform ‚Üí Undo all
4. Test: Drag-drop asset ‚Üí Rename ‚Üí Reparent ‚Üí Delete
5. Test: Create hierarchy ‚Üí Save ‚Üí Load ‚Üí Verify structure
6. Test: Fill scene with 1000 entities ‚Üí Check performance
7. Test: Rapid undo/redo 100 times ‚Üí Check stability

**Test Cases**:
- Complete editing workflows succeed
- Performance remains acceptable with large scenes
- Undo/redo handles complex scenarios
- No memory leaks in long sessions

**Acceptance**:
- All workflows work end-to-end
- Performance meets requirements
- Stability is rock-solid

---

#### T7.2: UI Polish and Usability
**Atomic Functionality**: Improve visual feedback and UX

**Files**:
- All panel implementation files

**Implementation Steps**:
1. Add tooltips to all buttons and controls
2. Add icons where appropriate (using ImGui icon fonts)
3. Improve spacing and padding in panels
4. Add visual separators between sections
5. Use colors consistently (selection, hover, active)
6. Add loading indicators for slow operations
7. Improve error messages with actionable suggestions

**Test Cases**:
- All interactive elements have tooltips
- UI feels responsive and polished
- Colors and spacing are consistent
- Error messages are helpful

**Acceptance**:
- Professional-looking UI
- Easy to learn and use
- Consistent with industry standards

---

#### T7.3: Performance Optimization
**Atomic Functionality**: Ensure smooth operation with large scenes

**Files**:
- All implementation files

**Implementation Steps**:
1. Profile hierarchy panel with 10,000 entities
2. Implement virtual scrolling if needed (ImGui clipper)
3. Cache entity lookups in panels
4. Batch component queries where possible
5. Profile inspector with complex entities
6. Optimize asset browser with many files
7. Add progress bars for slow operations

**Test Cases**:
- Hierarchy with 10,000 entities maintains 60fps
- Inspector updates smoothly during dragging
- Asset browser scrolls smoothly with 1000+ files
- No UI stuttering during complex operations

**Acceptance**:
- Smooth UI at all times
- Large scenes are usable
- No performance regressions

---

#### T7.4: Documentation and Examples
**Atomic Functionality**: Document usage and provide examples

**Files**:
- `docs/scene_editor_guide.md` (new)
- `docs/scene_format_spec.md` (new)
- `assets/examples/example_scene.json` (new)

**Implementation Steps**:
1. Write user guide for scene editor
2. Document all keyboard shortcuts
3. Document all menu commands
4. Write scene format specification
5. Create example scene files
6. Add code comments to public APIs
7. Create video/GIF demonstrations (optional)

**Test Cases**:
- Documentation covers all features
- Examples load successfully
- Instructions are clear and accurate

**Acceptance**:
- Complete documentation
- Easy to learn for new users
- Reference for all features

---

## üß™ Testing Strategy

### Unit Tests
Each task includes unit tests for:
- Panel rendering without errors
- Command creation and execution
- UI state management
- File I/O operations

### Integration Tests
- Complete editing workflows (T7.1)
- Cross-panel interactions
- Undo/redo across all operations
- Save/load round-trip verification
- Existing UI integration (no regressions)
- Viewport rendering updates from inspector changes
- Camera focus and navigation

### Performance Tests
- Large scene handling (10,000+ entities)
- Rapid command execution
- UI responsiveness under load
- Memory leak detection

### Manual Testing
- UI visual verification
- Interaction feel and polish
- Error message clarity
- Keyboard shortcut conflicts

---

## üìà Success Metrics

### Functional Completeness
- ‚úÖ All panels render and function correctly
- ‚úÖ All editing operations work through commands
- ‚úÖ Scene save/load is lossless
- ‚úÖ Multi-selection works across all panels
- ‚úÖ Drag-and-drop operations are intuitive

### Performance
- ‚úÖ 60fps UI with 1,000 entities
- ‚úÖ 30fps UI with 10,000 entities
- ‚úÖ < 100ms scene save/load for typical scenes
- ‚úÖ < 16ms input response time

### Quality
- ‚úÖ No crashes in normal operation
- ‚úÖ No memory leaks in extended sessions
- ‚úÖ Clear error messages for all failure cases
- ‚úÖ Comprehensive test coverage (>85%)

### Usability
- ‚úÖ Intuitive for users familiar with Unity/Unreal
- ‚úÖ All common operations accessible via keyboard
- ‚úÖ Clear visual feedback for all actions
- ‚úÖ Consistent UI/UX across all panels

---

## üöÄ Deliverables

1. **Scene Hierarchy Panel** - Complete tree view with drag-and-drop
2. **Entity Inspector Panel** - Component editing with undo/redo
3. **Asset Browser Panel** - File navigation and asset import
4. **Scene Editor** - Integrated editing environment
5. **Scene Serialization** - JSON save/load system
6. **Comprehensive Tests** - Unit, integration, and performance tests
7. **Documentation** - User guide and technical specs

---

## ‚å®Ô∏è Keyboard Shortcuts Reference

This section documents all keyboard shortcuts that should be implemented across the scene editor:

### Global Shortcuts
- **Ctrl+N**: New Scene
- **Ctrl+O**: Open Scene
- **Ctrl+S**: Save Scene
- **Ctrl+Shift+S**: Save Scene As
- **Ctrl+Z**: Undo
- **Ctrl+Y** or **Ctrl+Shift+Z**: Redo
- **Delete**: Delete selected entities
- **Ctrl+D**: Duplicate selected entities
- **F**: Frame selected entity in viewport
- **Escape**: Clear selection

### Gizmo Mode Shortcuts
- **W**: Translate mode
- **E**: Rotate mode  
- **R**: Scale mode
- **Q**: No gizmo

### Hierarchy Panel Shortcuts
- **F2**: Rename selected entity
- **Ctrl+C**: Copy entity (future)
- **Ctrl+V**: Paste entity (future)
- **Ctrl+X**: Cut entity (future)
- **Ctrl+A**: Select all entities (future)

### Inspector Panel Shortcuts
- **Ctrl+Click** on component header: Collapse/expand
- **Alt+Click** on vec3 component: Reset to default

### Asset Browser Shortcuts
- **Backspace**: Go up one directory level
- **Enter**: Open selected folder
- **Ctrl+F**: Focus search field (future)

---

## üìã Dependencies

### From Previous Phases
- **Phase 1**: ECS with hierarchy and components
  - `ecs::Scene` with entity management
  - `Scene::setParent()`, `getParent()`, `getChildren()` for hierarchy
  - Components: Transform, Name, Visible, MeshRenderer, Selected
- **Phase 2**: Asset pipeline with glTF loading
  - `assets::AssetManager` for asset management
  - `assets::MeshHandle` system
  - glTF import functionality
- **Phase 2.5**: GPU Resource Management
  - `engine::GPUResourceManager` for GPU resource caching
  - `engine::gpu::MeshGPU` for GPU mesh data
- **Phase 3**: Selection system with picking
  - `editor::SelectionManager` for selection tracking
  - `picking::PickingSystem` for ray-cast picking
- **Phase 4**: Gizmo system for transformations
  - `editor::GizmoSystem` for gizmo rendering and interaction
  - Transform gizmo modes (translate/rotate/scale)
- **Phase 5**: Command system with undo/redo
  - `CommandHistory` class for undo/redo stack
  - Existing commands: `CreateEntityCommand`, `DeleteEntityCommand`, `AddComponentCommand`, `RemoveComponentCommand`, `SetParentCommand`, `RenameEntityCommand`
  - `TransformEntityCommand` and `BatchTransformCommand` for gizmo integration
  - Command merging support for continuous operations

### New Commands for Phase 6
The following commands need to be implemented for Phase 6 functionality:

1. **DuplicateEntityCommand** (T1.5)
   - Duplicates entity with all components
   - Handles hierarchy recursion
   - Adjusts names and positions

2. **ModifyComponentCommand<T>** (T1.6, T2.3, T2.4)
   - Generic command for modifying any component
   - Stores old and new component state
   - Supports command merging for continuous edits

3. **CreateEntityFromAssetCommand** (T3.7)
   - Creates entity from dragged asset
   - Loads mesh and assigns MeshRenderer
   - Positions entity at drop location

4. **BatchModifyCommand** (T2.8)
   - Modifies same component on multiple entities
   - Used for multi-selection edits
   - Stores per-entity old/new states

These build upon the command infrastructure from Phase 5.

### External Libraries
- **ImGui**: Already integrated, used for all UI
- **nlohmann/json**: For scene serialization (add to vcpkg.json if not present)
- **std::filesystem**: For file system navigation (C++17 standard)

### Build System
- Update CMakeLists.txt to include new source directories:
  - `src/editor/scene_hierarchy/`
  - `src/editor/entity_inspector/`
  - `src/editor/asset_browser/`
  - `src/editor/scene_editor/`
  - `src/runtime/scene_serialization/`

---

## üîÑ Implementation Order

### Week 1: Foundation and Analysis
1. T4.0: Analyze existing UI class and plan integration
2. T1.1-T1.3: Basic hierarchy panel with selection
3. T2.1-T2.3: Inspector foundation with transform editing
4. T3.1-T3.3: Asset browser with navigation

### Week 2: Advanced Features
5. T1.4-T1.7: Hierarchy drag-and-drop, context menu, and camera focus
6. T2.4-T2.8: Complete inspector with all components and multi-selection
7. T3.4-T3.7: Asset browser with import and drag-drop

### Week 3: Integration, Rendering, and Polish
8. T4.1-T4.6: Scene editor integration with existing UI
9. T5.1-T5.4: Scene serialization
10. T6.0: Renderer integration and visibility
11. T7.1-T7.4: Testing, optimization, and documentation

---

## üéØ Completion Criteria

Phase 6 is complete when:

1. ‚úÖ All three panels (hierarchy, inspector, asset browser) are functional
2. ‚úÖ Scene editor orchestrates all systems correctly
3. ‚úÖ Scene save/load works reliably
4. ‚úÖ All editing operations support undo/redo
5. ‚úÖ Multi-selection works consistently
6. ‚úÖ Drag-and-drop operations are smooth
7. ‚úÖ Performance meets targets with large scenes
8. ‚úÖ All tests pass (unit, integration, performance)
9. ‚úÖ Documentation is complete and accurate
10. ‚úÖ Code review approval from team

---

## üìù Notes

### Design Decisions
- **Immediate Mode UI**: ImGui simplifies state management and integration
- **Command Pattern**: All edits go through commands for consistent undo/redo
- **JSON Format**: Human-readable and easy to version control
- **Modular Panels**: Each panel is independent and reusable

### Future Enhancements (Post-Phase 6)
- Asset thumbnails with 3D preview rendering
- Native file dialogs (Windows IFileDialog, platform-specific)
- Search and filter in hierarchy and asset browser
- Favorites/bookmarks in asset browser
- Prefab system for reusable entity templates
- Scene templates for quick start
- Collaborative editing (multi-user)

### Known Limitations
- No 3D asset preview (text-based preview only)
- No texture preview (future enhancement)
- Limited file operations (no cut/paste/duplicate for assets)
- Single scene per editor instance
- No real-time collaboration
- No auto-save functionality (should be added for safety)

### UI/UX Considerations

#### Color Scheme and Theming
- Use consistent ImGui colors for selection, hover, active states
- Selected entities: Orange/gold highlight
- Hovered entities: Subtle blue-gray highlight
- Modified values in inspector: Different color until saved
- Error states: Red text/background

#### Responsive Feedback
- Show loading spinners for long operations (>100ms)
- Disable UI elements during processing
- Show progress bars for batch operations
- Provide audio/visual feedback for errors
- Toast notifications for successful operations

#### Accessibility
- Tooltip on every interactive element (delay: 0.5s)
- Keyboard navigation support throughout
- Clear focus indicators
- Readable font sizes (minimum 12pt)
- Sufficient color contrast

#### Performance Targets
- Hierarchy update: <16ms for 1000 entities
- Inspector update: <5ms per frame
- Asset browser grid render: <16ms for 500 files
- Search/filter: <50ms for 10,000 entities

---

## üîó Related Documents

- **MILESTONE_2.md**: Overall milestone plan
- **M2_P1.md**: Enhanced ECS System
- **M2_P2.md**: glTF Asset Import Pipeline
- **M2_P3.md**: Object Picking & Selection System
- **M2_P4.md**: 3D Gizmo Manipulation System
- **M2_P5.md**: Undo/Redo Command Stack
- **PROGRESS_2.md**: Implementation progress tracking

---

**End of Phase 6 Implementation Plan**

# Milestone 2 – Phase 2 (glTF Asset Import Pipeline) Remaining Work

Date: 2025-09-07 (Updated for Primitive-Based Design)
Context: Phase 2 intends to deliver a production‑ready glTF 2.0 import pipeline (meshes, materials, hierarchy) integrated with asset management and ready to feed the ECS. Current implementation is a minimal placeholder (node traversal only). This document enumerates remaining work to reach the milestone definition.

## 🔄 **IMPORTANT DESIGN UPDATE**
**The mesh architecture has been redesigned to support a primitive-based approach:**
- **OLD**: Single vertex/index buffer per mesh (aggregated primitives)
- **NEW**: Collection of `Primitive` objects per mesh (preserves glTF structure)
- **Benefits**: Per-primitive materials, GPU efficiency, glTF fidelity, modern rendering alignment

This change affects mesh extraction, GPU resource management, ECS integration, and testing approaches detailed below.

## 🎯 Phase 2 Goal (Recap)
Provide a robust, extensible asset pipeline that can:
1. Parse glTF 2.0 (JSON + external/embedded buffers, minimal required extensions)
2. Extract meshes (positions, normals, tangents, UVs, indices) & compute missing data
3. Extract PBR material data (base color, metallic, roughness, emissive; basic textures)
4. Preserve transform hierarchy (local TRS -> entity Transform)
5. Create GPU buffers (vertex/index) & bounds
6. Cache & reuse assets via an AssetManager
7. Import scenes into ECS (entity tree + MeshRenderer + Name + Transform)
8. Provide tests for loader correctness & error conditions

## ✅ Delivered (Baseline)
- `engine.assets`: Basic Asset / Mesh / Material / Scene / SceneNode structures (simplified fields).
- `engine.gltf_loader`: Placeholder `loadScene` (returns empty), basic `loadFromString` JSON parsing with node traversal producing placeholder mesh/material markers.
- glTF dependency (cgltf) integrated; tests exercise JSON string parsing & minimal node + material presence detection.

## ❌ Missing / Incomplete Functional Areas
| Area | Current State | Required Completion |
|------|---------------|---------------------|
| File-based scene load | Returns empty scene | Full parse via cgltf_data (buffers, scenes) |
| Buffer / accessor resolution | Not implemented | Map accessors->views->buffers; support interleaved/strided |
| **Primitive extraction** | **No primitive separation** | **Extract each glTF primitive as separate Primitive object** |
| **Per-primitive materials** | **Not supported** | **Maintain material reference per primitive** |
| Missing data reconstruction | Not attempted | Generate normals (if absent); tangents (optional) |
| Index/vertex deduplication | Not implemented | Optional: hash-based or direct copy (MVP direct per primitive) |
| **Primitive bounds calculation** | **None** | **Compute AABB per primitive + aggregate mesh bounds** |
| Material parsing | Placeholder single marker | Parse pbrMetallicRoughness factors + texture references |
| Texture handling | Absent | Record texture URIs; (GPU upload deferred if out of scope) |
| Node transforms | Ignored | Apply TRS / matrix; compose into Transform component inputs |
| Skinning / animation | Not in scope (Phase 2) | Explicitly deferred |
| AssetManager | Missing | Implement caching, reference retrieval, unload |
| **Per-primitive GPU buffers** | **Not implemented** | **Create D3D12 buffers per primitive for modern rendering** |
| Error handling & logging | Minimal | Standardize return strategy + exceptions + diagnostics |
| **Primitive-aware ECS import** | **Full implementation** | **Convert SceneNode tree with primitive-based MeshRenderer** |
| Memory ownership | Raw conversions only | Shared_ptr management in AssetManager |
| **Primitive-based tests** | **Node/material placeholder only** | **Extensive primitive separation & material tests** |
| glTF variants | Only minimal inline JSON | Test external buffers (.bin), embedded base64, multi-mesh, multi-node |
| Performance considerations | Unmeasured | Basic profiling hooks for primitive-based loading |

## 📌 Task Breakdown
### ✅ 1. Loader Core (File Path) - COMPLETED
- Use cgltf: parse file, load buffers (`cgltf_load_buffers`), validate.
- Support .gltf + external buffers + embedded base64.
- Failure modes: missing file, invalid JSON, unsupported component types.

### ✅ 2. Accessor & Buffer View Handling - COMPLETED
- Utility to produce typed spans (float3 positions, float3 normals, float2 uv, float4 tangent, uint indices).
- Handle componentType combinations: positions (FLOAT), indices (UNSIGNED_SHORT/UNSIGNED_INT/UNSIGNED_BYTE → widen to uint32_t).

### ✅ 3. Mesh Extraction (Updated for Primitive-Based Design) - COMPLETED
- **NEW APPROACH**: Extract each glTF primitive as a separate `Primitive` object within a `Mesh`.
- Each primitive maintains its own vertex/index buffers and material reference.
- Build contiguous vertex/index arrays per primitive (not aggregated).
- Generate tangents only if TANGENT missing and NORMAL+TEXCOORD_0 present (defer if time).
- Compute local AABB per primitive and aggregate for overall mesh bounds.
- **Key Change**: Preserve glTF primitive structure instead of flattening to single buffers.

### ✅ 4. Material Parsing - COMPLETED
- Support baseColorFactor, metallicFactor, roughnessFactor, emissiveFactor.
- Capture texture slots (baseColorTexture, metallicRoughnessTexture, normalTexture, emissiveTexture) – store original relative URIs.
- Ignore unsupported extensions initially; log if encountered.

### ✅ 5. Scene Hierarchy / Transforms - COMPLETED
- Extract TRS (translation, rotation(quat), scale) or matrix fallback.
- Convert quaternion to Euler (if staying with Euler) or expand Transform to support quaternion (decision: keep Euler now, approximate; TODO queued for later).
- Compose world is deferred to TransformSystem after ECS import.

### ✅ 6. Bounds & Aggregation - COMPLETED
- ✅ Per-primitive AABB computed automatically when vertices are added via `addVertex()`
- ✅ Mesh local AABB aggregated from all primitive bounds when primitives are added via `addPrimitive()`
- ✅ BoundingBox3D integration provides validated bounds with `isValid()`, `center()`, `size()` methods
- ✅ Manual bounds recalculation available via `recalculateBounds()` method
- ✅ Comprehensive test coverage for both primitive and mesh bounds in assets_tests.cpp and gltf_loader_tests.cpp
- For Scene import: compute per-entity world AABB lazily when needed (not in loader).

### ✅ 7. AssetManager Implementation - COMPLETED
- ✅ API: `load<T>(path)`, `get<T>(path)`, `store<T>(path, asset)`, `unload(path)`, `clearCache()`, `isCached(path)`.
- ✅ Cache map<string, shared_ptr<Asset>> with reference counting.
- ✅ Template specializations for Scene, Material, and Mesh types.
- ✅ Reference counting implicit via shared_ptr; unload only when unique reference.
- ✅ ECS import API via callback pattern: `importScene(path, ecs::Scene&)` using `ImportSceneCallback`.
- ✅ Integration with glTF loader via store/get pattern to avoid circular dependencies.
- ✅ Comprehensive test coverage: 7 test cases with 39 assertions covering caching, unloading, integration, and ECS import.
- ✅ Thread-safe static callback mechanism for external ECS integration.
- Optional: memory usage introspection (deferred).

### ✅ 8. ECS Import (Updated for Primitive-Based Design) - COMPLETED
- For each SceneNode:
  - Create entity with Name component (node.name).
  - Add Transform from node local TRS.
  - For each mesh, attach MeshRenderer with primitive-aware material handling.
  - **NEW**: Support material overrides per primitive in MeshRenderer component.
  - Set parent relationships.
- **Key Change**: MeshRenderer now works with primitive-based meshes, supporting per-primitive materials.

### ✅ 9. GPU Buffer Creation (Updated for Primitive-Based Design) - COMPLETED
- ✅ **NEW APPROACH**: Each primitive manages its own GPU resources via `PrimitiveGPUBuffer` class.
- ✅ Runtime-ready meshes: allocated upload heap buffers per primitive with D3D12 integration.
- ✅ Lightweight struct with buffer views per primitive: `D3D12_VERTEX_BUFFER_VIEW` and `D3D12_INDEX_BUFFER_VIEW`.
- ✅ **Key Benefit**: Optimized for modern rendering with per-primitive draw calls.
- ✅ **Implementation Details**: 
  - New `engine.asset_gpu_buffers` module with `PrimitiveGPUBuffer` and `MeshGPUBuffers` classes
  - Upload heap allocation for vertex and index data
  - Proper error handling for empty primitives
  - Resource lifecycle management with RAII
  - Comprehensive test coverage (6 test cases with 30 assertions)

### 10. Error Handling Strategy
- Use console::fatal for fatal parse errors (file missing, invalid format).
- For recoverable missing optional attributes: log + continue.
- Provide `enum class LoadError` if shifting away from exceptions later (deferred).

### 11. Testing Plan
Add test categories (Catch2):
- **Primitive-based mesh tests**: Individual primitive vertex/index counts & bounds.
- Multiple primitives in single mesh -> correctly separated (not aggregated).
- **Per-primitive materials**: Verify each primitive maintains its material reference.
- Missing normals (normal generation optional test - mark skipped if not implemented).
- Material factors parsing (baseColor, metallic, roughness).
- Texture reference extraction (presence, path strings).
- Hierarchy depth (multi-level nodes).
- External buffer file resolution.
- Failure cases: bad path, wrong accessor types, truncated buffer.
- **Updated ECS import**: entity count == node count; MeshRenderer supports primitives.
- Asset caching: second load returns same shared_ptr.
- **Primitive GPU resources**: Each primitive has independent buffers.

### 12. Performance & Scalability (MVP)
- Big scene synthetic test (many small nodes) measuring load time (basic timing log only).
- Ensure no quadratic string concatenations / repeated reallocations inside loops.

### 13. Documentation / Developer Notes
- Add comments in `gltf_loader` outlining supported attributes & limitations.
- README snippet (or section in `PROGRESS_2.md`) describing import pipeline and extension points.

## ✅ Acceptance Criteria Checklist (Updated for Primitive-Based Design)
- [ ] File-based `loadScene(path)` builds hierarchy with real nodes.
- [ ] **Primitive-based meshes**: Each glTF primitive becomes separate `Primitive` object.
- [ ] **Per-primitive data**: Vertices/indices populated per primitive (not aggregated).
- [ ] **Per-primitive materials**: Each primitive maintains its material reference.
- [ ] Material PBR factors parsed (validated via tests).
- [ ] Texture path strings captured for at least base color.
- ✅ **Primitive bounds**: Local AABB computed per primitive and aggregated for mesh.
- ✅ AssetManager caches and reuses primitive-based assets.
- ✅ AssetManager provides ECS import callback mechanism with `importScene(path, ecs::Scene&)`.
- ✅ `importScene` creates ECS entities with primitive-aware MeshRenderer components.
- ✅ **GPU Buffer Creation**: Per-primitive D3D12 buffers with proper resource management.
- [ ] **Updated tests**: At least 10 new tests covering primitive separation and material handling.
- [ ] Graceful handling of unsupported attributes (logged, not crash).
- [ ] Documentation of primitive-based architecture included.

## ⏳ Estimated Effort (Updated for Primitive-Based Design)
| Task Group | Est. Hours | Notes |
|------------|------------|-------|
| Core parsing (buffers/accessors) | 4.0 | Same complexity |
| **Primitive extraction + bounds** | **4.0** | **+1h for primitive separation logic** |
| Material & textures parsing | 2.0 | Same complexity |
| **Primitive-aware AssetManager** | **2.5** | **+0.5h for primitive resource management** |
| **Primitive-aware ECS import** | **2.5** | **+0.5h for MeshRenderer primitive support** |
| **Primitive-based tests** | **5.0** | **+1h for additional primitive test coverage** |
| **Per-primitive GPU buffers** | **4.0** | **+1h for individual primitive resource management** |
| Documentation & cleanup | 1.0 | Same |
| **Total (no GPU)** | **20.0** | **+2h from original** |
| **Total (with GPU)** | **24.0** | **+3h from original** |

## 🚩 Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|-----------|
| Complex attribute permutations | Parsing bugs | Start with POSITION/NORMAL/TEXCOORD_0/indices; incremental tests |
| Tangent generation complexity | Time overrun | Defer; use placeholder tangents (0,0,0,1) |
| Large file memory spikes | Allocation pressure | Reserve vertices/indices using accessor counts |
| ECS import duplication | Entity bloat | Centralize import logic, idempotent import or explicit new scene creation |
| Texture path handling across platforms | Incorrect relative paths | Normalize using std::filesystem | 

## 🔮 Deferred (Explicitly Out of Phase 2 Scope)
- Animation (skins, bones, morph targets)
- Advanced material extensions (KHR_materials_* extras)
- Texture decoding & GPU upload pipeline (beyond capturing URIs)
- Mesh compression (Draco), bin packing, streaming
- Async / multithreaded loading

## 🧱 Technical Decisions (Proposed)
| Decision | Rationale |
|----------|----------|
| **Primitive-based Mesh architecture** | **Aligns with glTF spec; enables per-primitive materials; optimizes GPU rendering** |
| Euler angles only in Transform | Simplicity; revisit with animation milestone |
| Exceptions for fatal errors | Cleaner early implementation; convert later if needed |
| Shared_ptr asset caching | Simplicity vs intrusive ref counting |
| **Per-primitive GPU buffers** | **Modern rendering efficiency; individual resource management** |
| No tangent generation initially | Not needed until advanced shading |

## 📣 Next Steps (Updated for Primitive-Based Design)
1. **Implement primitive extraction logic** in glTF loader (each glTF primitive → Primitive object)
2. **Update existing tests** to work with primitive-based mesh structure  
3. **Proceed with enhanced loader core** (buffers + primitive extraction) to unblock downstream systems
4. **Integrate primitive-aware ECS import** with updated MeshRenderer component
5. **Add comprehensive primitive-based tests** and refine materials handling

**Priority Order**: Primitive extraction → Test updates → Asset manager → ECS integration → GPU resources

---
(Updated for primitive-based mesh architecture. Previous aggregation approach deprecated.)

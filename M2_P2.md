# Milestone 2 ‚Äì Phase 2 (glTF Asset Import Pipeline) Remaining Work

Date: 2025-09-06
Context: Phase 2 intends to deliver a production‚Äëready glTF 2.0 import pipeline (meshes, materials, hierarchy) integrated with asset management and ready to feed the ECS. Current implementation is a minimal placeholder (node traversal only). This document enumerates remaining work to reach the milestone definition.

## üéØ Phase 2 Goal (Recap)
Provide a robust, extensible asset pipeline that can:
1. Parse glTF 2.0 (JSON + external/embedded buffers, minimal required extensions)
2. Extract meshes (positions, normals, tangents, UVs, indices) & compute missing data
3. Extract PBR material data (base color, metallic, roughness, emissive; basic textures)
4. Preserve transform hierarchy (local TRS -> entity Transform)
5. Create GPU buffers (vertex/index) & bounds
6. Cache & reuse assets via an AssetManager
7. Import scenes into ECS (entity tree + MeshRenderer + Name + Transform)
8. Provide tests for loader correctness & error conditions

## ‚úÖ Delivered (Baseline)
- `engine.assets`: Basic Asset / Mesh / Material / Scene / SceneNode structures (simplified fields).
- `engine.gltf_loader`: Placeholder `loadScene` (returns empty), basic `loadFromString` JSON parsing with node traversal producing placeholder mesh/material markers.
- glTF dependency (cgltf) integrated; tests exercise JSON string parsing & minimal node + material presence detection.

## ‚ùå Missing / Incomplete Functional Areas
| Area | Current State | Required Completion |
|------|---------------|---------------------|
| File-based scene load | Returns empty scene | Full parse via cgltf_data (buffers, scenes) |
| Buffer / accessor resolution | Not implemented | Map accessors->views->buffers; support interleaved/strided |
| Mesh attribute extraction | No real mesh data | Extract POSITION/NORMAL/TEXCOORD_0/TANGENT/indices |
| Missing data reconstruction | Not attempted | Generate normals (if absent); tangents (optional) |
| Index/vertex deduplication | Not implemented | Optional: hash-based or direct copy (MVP direct) |
| Bounds calculation | None | Compute AABB per mesh & aggregate scene bounds |
| Material parsing | Placeholder single marker | Parse pbrMetallicRoughness factors + texture references |
| Texture handling | Absent | Record texture URIs; (GPU upload deferred if out of scope) |
| Node transforms | Ignored | Apply TRS / matrix; compose into Transform component inputs |
| Skinning / animation | Not in scope (Phase 2) | Explicitly deferred |
| AssetManager | Missing | Implement caching, reference retrieval, unload |
| GPU buffer creation | Not implemented | Create D3D12 buffers (defer if Phase 2 strictly CPU) |
| Error handling & logging | Minimal | Standardize return strategy + exceptions + diagnostics |
| ECS import | None | Convert SceneNode tree into ECS entities & components |
| Memory ownership | Raw conversions only | Shared_ptr management in AssetManager |
| Tests (mesh/material) | Node/material placeholder only | Extensive functional & edge case coverage |
| glTF variants | Only minimal inline JSON | Test external buffers (.bin), embedded base64, multi-mesh, multi-node |
| Performance considerations | Unmeasured | Basic profiling hooks or at least large-scene test |

## üìå Task Breakdown
### 1. Loader Core (File Path)
- Use cgltf: parse file, load buffers (`cgltf_load_buffers`), validate.
- Support .gltf + external buffers + embedded base64.
- Failure modes: missing file, invalid JSON, unsupported component types.

### 2. Accessor & Buffer View Handling
- Utility to produce typed spans (float3 positions, float3 normals, float2 uv, float4 tangent, uint indices).
- Handle componentType combinations: positions (FLOAT), indices (UNSIGNED_SHORT/UNSIGNED_INT/UNSIGNED_BYTE ‚Üí widen to uint32_t).

### 3. Mesh Extraction
- For each primitive: build contiguous vertex/index arrays.
- Generate tangents only if TANGENT missing and NORMAL+TEXCOORD_0 present (defer if time).
- Compute local AABB while iterating vertices.

### 4. Material Parsing
- Support baseColorFactor, metallicFactor, roughnessFactor, emissiveFactor.
- Capture texture slots (baseColorTexture, metallicRoughnessTexture, normalTexture, emissiveTexture) ‚Äì store original relative URIs.
- Ignore unsupported extensions initially; log if encountered.

### 5. Scene Hierarchy / Transforms
- Extract TRS (translation, rotation(quat), scale) or matrix fallback.
- Convert quaternion to Euler (if staying with Euler) or expand Transform to support quaternion (decision: keep Euler now, approximate; TODO queued for later).
- Compose world is deferred to TransformSystem after ECS import.

### 6. Bounds & Aggregation
- Mesh local AABB stored in Mesh.
- For Scene import: compute per-entity world AABB lazily when needed (not in loader).

### 7. AssetManager Implementation
- API: `load<T>(path)`, `get<T>(path)`, `importScene(path, ecs::Scene&)`.
- Cache map<string, shared_ptr<Asset>>.
- Reference counting implicit via shared_ptr.
- Unload: erase entry if unique.
- Optional: memory usage introspection (defer).

### 8. ECS Import
- For each SceneNode:
  - Create entity with Name component (node.name).
  - Add Transform from node local TRS.
  - For each mesh index/material pair, attach MeshRenderer (one per entity or multiple? MVP: single, extend later).
  - Set parent relationships.

### 9. GPU Buffer Creation (Conditional)
- If Phase 2 requires runtime-ready meshes: allocate default/upload heap buffers for vertex & index data.
- Provide lightweight struct with buffer views.
- If deferred: leave TODO + test only CPU data integrity.

### 10. Error Handling Strategy
- Use exceptions for fatal parse errors (file missing, invalid format).
- For recoverable missing optional attributes: log + continue.
- Provide `enum class LoadError` if shifting away from exceptions later (deferred).

### 11. Testing Plan
Add test categories (Catch2):
- Mesh attribute counts & bounds (simple cube).
- Multiple primitives in single mesh -> aggregated correctly.
- Missing normals (normal generation optional test - mark skipped if not implemented).
- Material factors parsing (baseColor, metallic, roughness).
- Texture reference extraction (presence, path strings).
- Hierarchy depth (multi-level nodes).
- External buffer file resolution.
- Failure cases: bad path, wrong accessor types, truncated buffer.
- Import to ECS: entity count == node count; parent relationships preserved; MeshRenderer presence.
- Asset caching: second load returns same shared_ptr.

### 12. Performance & Scalability (MVP)
- Big scene synthetic test (many small nodes) measuring load time (basic timing log only).
- Ensure no quadratic string concatenations / repeated reallocations inside loops.

### 13. Documentation / Developer Notes
- Add comments in `gltf_loader` outlining supported attributes & limitations.
- README snippet (or section in `PROGRESS_2.md`) describing import pipeline and extension points.

## ‚úÖ Acceptance Criteria Checklist
- [ ] File-based `loadScene(path)` builds hierarchy with real nodes.
- [ ] Mesh vertices/indices populated (counts > 0) for test glTF assets.
- [ ] Material PBR factors parsed (validated via tests).
- [ ] Texture path strings captured for at least base color.
- [ ] Mesh local AABB computed & stored.
- [ ] AssetManager caches and reuses assets.
- [ ] `importScene` creates ECS entities/components with correct parent/child relations.
- [ ] At least 8 new focused tests passing (mesh, material, hierarchy, caching, failure path, ECS import).
- [ ] Graceful handling of unsupported attributes (logged, not crash).
- [ ] Documentation of limitations included.

## ‚è≥ Estimated Effort
| Task Group | Est. Hours |
|------------|------------|
| Core parsing (buffers/accessors) | 4.0 |
| Mesh extraction + bounds | 3.0 |
| Material & textures parsing | 2.0 |
| AssetManager + caching | 2.0 |
| ECS import function | 2.0 |
| Tests authoring (8‚Äì10 cases) | 4.0 |
| Optional GPU buffer upload | 3.0 (defer reduces total) |
| Documentation & cleanup | 1.0 |
| **Total (no GPU)** | **18.0** |
| **Total (with GPU)** | **21.0** |

## üö© Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|-----------|
| Complex attribute permutations | Parsing bugs | Start with POSITION/NORMAL/TEXCOORD_0/indices; incremental tests |
| Tangent generation complexity | Time overrun | Defer; use placeholder tangents (0,0,0,1) |
| Large file memory spikes | Allocation pressure | Reserve vertices/indices using accessor counts |
| ECS import duplication | Entity bloat | Centralize import logic, idempotent import or explicit new scene creation |
| Texture path handling across platforms | Incorrect relative paths | Normalize using std::filesystem | 

## üîÆ Deferred (Explicitly Out of Phase 2 Scope)
- Animation (skins, bones, morph targets)
- Advanced material extensions (KHR_materials_* extras)
- Texture decoding & GPU upload pipeline (beyond capturing URIs)
- Mesh compression (Draco), bin packing, streaming
- Async / multithreaded loading

## üß± Technical Decisions (Proposed)
| Decision | Rationale |
|----------|----------|
| Euler angles only in Transform | Simplicity; revisit with animation milestone |
| Exceptions for fatal errors | Cleaner early implementation; convert later if needed |
| Shared_ptr asset caching | Simplicity vs intrusive ref counting |
| Single MeshRenderer per entity (MVP) | Minimizes complexity; primitives aggregated |
| No tangent generation initially | Not needed until advanced shading |

## üì£ Next Step
Proceed with loader core (buffers + mesh extraction) first to unblock downstream systems (selection, rendering integration). After ECS import works, integrate tests and refine materials.

---
(Generated. Request edits or a condensed Kanban-style list if preferred.)

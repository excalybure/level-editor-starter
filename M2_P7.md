# Milestone 2 - Phase 7: Data-Driven Material System (Complete Implementation)

## üìã Overview

**Phase**: 7 (Material System - Phase 2)  
**Duration**: ~14-17 days (estimate from plan)  
**Dependencies**: Phase 1 (T001-T016) - Minimal Material System

**Goal**: Complete the data-driven material system by eliminating all hard-coded values in PSO creation. Replace hard-coded shaders, states, input layouts, and other PSO fields with JSON-specified data.

**Reference**: See `specs/001-data-driven-material/PHASE2_IMPLEMENTATION_PLAN.md`

---

## üéØ Phase Breakdown

### Phase 2A: Shader Information (T201-T203) ‚Äî COMPLETE
**Goal**: Replace hard-coded `simple.hlsl` with JSON-specified shader files, entry points, profiles.

**Status**: 
- ‚úÖ T201: Extend ShaderReference Struct (COMPLETED 2025-10-10)
- ‚úÖ T202: Update MaterialParser to Extract Shader Info (COMPLETED 2025-01-08)
- ‚úÖ T203: Update PipelineBuilder to Use Shader Info (COMPLETED 2025-10-10)

### Phase 2B: State Blocks (T204-T207) ‚Äî COMPLETE
**Goal**: Replace hard-coded D3D12 states with JSON-defined state blocks.

**Status**: 
- ‚úÖ T204: Define State Block Structs (COMPLETED 2025-10-10)
- ‚úÖ T205: Create State Block Parser (COMPLETED 2025-10-10)
- ‚úÖ T206: Integrate State Blocks into MaterialSystem (COMPLETED 2025-10-10)
- ‚úÖ T207: Update PipelineBuilder to Use State Blocks (COMPLETED 2025-10-11)

### Phase 2C: Vertex Formats (T208-T211) ‚Äî IN PROGRESS
**Goal**: Replace hard-coded input layout with JSON-defined vertex formats.

**Status**: 
- ‚úÖ T208: Define VertexFormat Structs (COMPLETED 2025-10-11)
- ‚úÖ T209: Parse Vertex Formats (COMPLETED 2025-10-11)
- ‚è≥ T210: Add vertexFormat to MaterialDef
- ‚è≥ T211: Use Vertex Format in PSO
- Next: T210 will add vertexFormat field to MaterialDefinition; T211 will use formats in PipelineBuilder to replace hardcoded POSITION+COLOR input layout

---

## ‚úÖ T207: Update PipelineBuilder to Use State Blocks ‚Äî COMPLETED

**Date**: 2025-10-11  
**Status**: ‚úÖ All tests passing (17 assertions in 6 pipeline-builder tests, 111 in full material-system suite)

### Implementation Summary
- **Updated buildPSO signature** ‚Äî Added optional `const MaterialSystem* materialSystem` parameter with default nullptr (backward compatible)
- **Query and apply rasterizer state** ‚Äî If material.states.rasterizer non-empty, query MaterialSystem and copy all 11 fields to psoDesc.RasterizerState; otherwise use D3D12 defaults
- **Query and apply depth/stencil state** ‚Äî Query via material.states.depthStencil, copy depth enable/write/func, stencil masks/ops; convert frontFace/backFace with toD3D12()
- **Query and apply blend state** ‚Äî Query via material.states.blend, copy alphaToCoverage/independentBlend flags, convert all 8 render target blend descriptors with toD3D12()
- **Query and apply render target state** ‚Äî If material.states.renderTarget specified, use rtvFormats/dsvFormat/sample desc from state block instead of passConfig
- **Fallback to defaults** ‚Äî If MaterialSystem nullptr, state ID empty, or state not found, PSO uses D3D12/passConfig defaults (backward compatible)

### Atomic Functionalities Completed
1. **AF1: Test for rasterizer state** ‚Äî Added integration test with wireframe material; PSO creation succeeds with MaterialSystem state query
2. **AF2: Pass MaterialSystem to buildPSO** ‚Äî Updated signature with optional parameter; updated all call sites (existing tests continue working with nullptr)
3. **AF3: Query and apply rasterizer state** ‚Äî Added query logic checking materialSystem && !states.rasterizer.empty(); applied all 11 fields including conservativeRaster conversion (bool‚ÜíMODE_ON/OFF)
4. **AF4: Query and apply depth/stencil state** ‚Äî Query depth/stencil state, copy all fields, convert frontFace/backFace stencil ops using DepthStencilOpDesc::toD3D12()
5. **AF5: Query and apply blend state** ‚Äî Query blend state, copy alphaToCoverage/independentBlend, iterate 8 render targets calling BlendRenderTargetState::toD3D12()
6. **AF6: Query and apply render target state** ‚Äî If renderTarget state specified, use its rtvFormats (vector size), dsvFormat, sampleCount/sampleQuality; otherwise use passConfig values

### Tests Added
1. `PipelineBuilder uses rasterizer state from MaterialSystem` ‚Äî Loads JSON with Wireframe rasterizer state (fillMode=Wireframe, cullMode=None, depthClipEnable=false); material references state; PSO created successfully (4 assertions)
2. `PipelineBuilder uses depth stencil state from MaterialSystem` ‚Äî Loads JSON with DepthReadOnly state (depthWriteMask=Zero); material references state; PSO builds (4 assertions)
3. `PipelineBuilder uses blend state from MaterialSystem` ‚Äî Loads JSON with AlphaBlend state (RT0 blendEnable=true, srcBlend=SrcAlpha, destBlend=InvSrcAlpha); PSO builds (4 assertions)

### Files Modified
- `src/graphics/material_system/pipeline_builder.h` ‚Äî Added MaterialSystem forward declaration, updated buildPSO signature with optional `const MaterialSystem*` parameter (default nullptr)
- `src/graphics/material_system/pipeline_builder.cpp` ‚Äî Added material_system.h include; replaced all hardcoded D3D12 state initialization with state block queries (rasterizer, depth/stencil, blend, render target); added fallback branches using D3D12 defaults when state not found
- `tests/material_system_tests.cpp` ‚Äî Added 3 integration tests for T207 tagged [pipeline-builder][T207][integration]; each test creates MaterialSystem with state blocks, material referencing states, calls buildPSO with MaterialSystem pointer

### Test Results
```
unit_test_runner.exe "[pipeline-builder][T207]"
All tests passed (12 assertions in 3 test cases)

unit_test_runner.exe "[pipeline-builder]"
All tests passed (17 assertions in 6 test cases)

unit_test_runner.exe "[material-system]"
All tests passed (111 assertions in 16 test cases)
```

### Implementation Details
- **Query pattern**: All state queries check `materialSystem && !material.states.<category>.empty()` before calling MaterialSystem::get<Category>State()
- **Fallback logic**: If query returns nullptr (state not found) or MaterialSystem not provided, PSO uses D3D12 defaults (FILL_MODE_SOLID, CULL_MODE_BACK, etc.) ensuring backward compatibility
- **Conservative rasterization**: Boolean field converted to D3D12_CONSERVATIVE_RASTERIZATION_MODE enum (true‚ÜíON, false‚ÜíOFF)
- **toD3D12() conversions**: BlendRenderTargetState and DepthStencilOpDesc provide conversion methods returning D3D12 descriptor structs
- **Render target state override**: When renderTarget state specified, completely replaces passConfig values for rtvFormats, dsvFormat, sample desc; materials without renderTarget state use passConfig (common case for forward/deferred passes)
- **State reuse**: State blocks stored once in MaterialSystem, referenced by ID from multiple materials; enables shared configurations (e.g., "AlphaBlend" used by multiple transparent materials)

### Notes
- Completes Phase 2B (State Blocks: T204-T207) ‚Äî all hard-coded D3D12 state values eliminated from PipelineBuilder
- PSO creation now fully data-driven for rasterizer, depth/stencil, blend, and render target states
- Existing materials without state references continue working with D3D12 defaults (backward compatible)
- MaterialSystem parameter optional in buildPSO ‚Äî callers can pass nullptr to use defaults (useful for minimal test setups)
- Next: Phase 2C (Vertex Formats: T208-T211) ‚Äî replace hard-coded POSITION+COLOR input layout with JSON vertex format specification
- State block inheritance (base field) still not implemented ‚Äî deferred as not needed for current test scenarios; materials use standalone state blocks

---

## ‚è≥ Next Steps

**Phase 2C: Vertex Formats (T208-T211)**
- T208: Define VertexFormat Structs ‚Äî Create structs for input element descriptors
- T209: Parse Vertex Formats ‚Äî String‚ÜíDXGI_FORMAT/semantic/offset parsing
- T210: Add vertexFormat to MaterialDef ‚Äî Extend parser to extract vertex format reference
- T211: Use Vertex Format in PSO ‚Äî Replace hardcoded POSITION+COLOR layout with data-driven input elements

### Phase 2C: Vertex Formats (T208-T211)
**Goal**: Replace hard-coded input layout with JSON-defined vertex formats.

**Status**: 
- ‚úÖ T208: Define VertexFormat Structs (COMPLETED 2025-10-11)
- ‚úÖ T209: Parse Vertex Formats (COMPLETED 2025-10-11)
- ‚è≥ T210: Add vertexFormat to MaterialDef
- ‚è≥ T211: Use Vertex Format in PSO

### Phase 2D: Root Signature Integration (T214-T215)
**Goal**: Use generated root signature specs (from T013) in PSO creation.

**Status**: Not Started

### Phase 2E: Render Pass Config & Finalization (T216-T217, T212-T213)
**Goal**: Parse render passes from JSON; finalize all PSO fields.

**Status**: Not Started

---

## ‚úÖ T208: Define VertexFormat Structs ‚Äî COMPLETED

**Date**: 2025-10-11  
**Status**: ‚úÖ All tests passing (13 assertions in 2 T208 tests, 111 in full material-system suite)

### Implementation Summary
- **Created VertexElement struct** ‚Äî Represents single input element with semantic, format, offset, and D3D12 input classification fields
- **Created VertexFormat struct** ‚Äî Container for vertex layout with id, elements vector, and stride
- **D3D12 defaults** ‚Äî VertexElement fields match D3D12_INPUT_ELEMENT_DESC: semanticIndex=0, inputSlot=0, inputSlotClass=PER_VERTEX_DATA, instanceDataStepRate=0
- **Added to state_blocks.h** ‚Äî Both structs defined alongside other PSO configuration structs (rasterizer, depth/stencil, blend)

### Atomic Functionalities Completed
1. **AF1: Test for VertexElement defaults** ‚Äî Created test constructing VertexElement with POSITION/R32G32B32_FLOAT, verifying default values (semanticIndex=0, inputSlot=0, inputSlotClass=PER_VERTEX_DATA, instanceDataStepRate=0); 4 assertions
2. **AF2: Define VertexElement struct** ‚Äî Added struct to state_blocks.h with 8 fields: semantic (string), semanticIndex (UINT=0), format (DXGI_FORMAT), inputSlot (UINT=0), alignedByteOffset (UINT), inputSlotClass (D3D12_INPUT_CLASSIFICATION=PER_VERTEX_DATA), instanceDataStepRate (UINT=0)
3. **AF3: Test for VertexFormat structure** ‚Äî Created test building VertexFormat with "PositionColor" id, stride=28, 2 elements (POSITION at offset 0, COLOR at offset 12); verifies id, stride, element count, and element fields; 9 assertions
4. **AF4: Define VertexFormat struct** ‚Äî Added struct to state_blocks.h with 3 fields: id (string), elements (vector<VertexElement>), stride (UINT)

### Tests Added
1. `VertexElement has correct D3D12 defaults` ‚Äî Default-constructs VertexElement, sets semantic/format/offset, verifies semanticIndex=0, inputSlot=0, inputSlotClass=PER_VERTEX_DATA, instanceDataStepRate=0 (4 assertions)
2. `VertexFormat contains id, elements, and stride` ‚Äî Constructs VertexFormat with "PositionColor" id, stride=28, POSITION+COLOR elements; verifies all structure fields including element semantics, formats, and offsets (9 assertions)

### Files Modified
- `src/graphics/material_system/state_blocks.h` ‚Äî Added VertexElement struct (8 fields) and VertexFormat struct (3 fields) at end of file before closing namespace
- `tests/material_system_tests.cpp` ‚Äî Added 2 test cases for T208 tagged [vertex-format][T208][unit] after T204 tests

### Test Results
```
unit_test_runner.exe "[vertex-format][T208]"
All tests passed (13 assertions in 2 test cases)

unit_test_runner.exe "[material-system]"
All tests passed (111 assertions in 16 test cases)
```

### Implementation Details
- **VertexElement mirrors D3D12_INPUT_ELEMENT_DESC**: All fields map 1:1 to D3D12 input element descriptor; simplifies conversion when building PSO (T211 will create D3D12_INPUT_ELEMENT_DESC array from VertexElement vector)
- **Default values match D3D12 common usage**: semanticIndex=0 (first instance of semantic), inputSlot=0 (buffer binding slot 0), inputSlotClass=PER_VERTEX_DATA (vertex data not instance data), instanceDataStepRate=0 (not used for per-vertex data)
- **Semantic as string**: Enables JSON parsing of semantic names ("POSITION", "NORMAL", "TEXCOORD", etc.); T211 will convert to const char* for D3D12 API
- **Stride in VertexFormat**: Specifies vertex buffer stride (size of one vertex in bytes); required for binding vertex buffers; calculated as sum of element sizes plus padding
- **VertexFormat reusable**: Multiple materials can reference same vertex format by id (e.g., "PositionNormalUV" shared by all lit opaque materials)
- **Foundation for T209-T211**: Structs provide storage for JSON-parsed vertex formats; T209 will parse "vertexFormats" section; T210 will add vertexFormat reference to MaterialDefinition; T211 will use formats in PipelineBuilder

### Notes
- Completes 1/4 tasks in Phase 2C (Vertex Formats)
- Structs follow same pattern as state blocks (id, fields, no inheritance for now)
- No toD3D12() conversion method needed ‚Äî T211 will manually construct D3D12_INPUT_ELEMENT_DESC array (semantic.c_str() requires string lifetime management)
- Tests verify struct layout and default values; no parser or integration yet (T209, T210, T211)
- Next: T209 will create vertex format parser with DXGI_FORMAT string‚Üíenum mapping, parse "vertexFormats" JSON section, integrate into MaterialSystem

---

## ‚úÖ T209: Parse Vertex Formats ‚Äî COMPLETED

**Date**: 2025-10-11  
**Status**: ‚úÖ All tests passing (46 assertions in 3 T209 tests, 136 in full material-system suite)

### Implementation Summary
- **Extended parseFormat** ‚Äî Added vertex-specific DXGI formats (R32G32B32_FLOAT, R32G32_FLOAT, R32_FLOAT) to StateBlockParser::parseFormat mapping
- **Created parseVertexFormat** ‚Äî New StateBlockParser method extracts id, stride, elements array from JSON; parses each element's semantic, format, offset with D3D12 defaults
- **Added MaterialSystem storage** ‚Äî New m_vertexFormats map stores VertexFormat by id; getVertexFormat query method returns const pointer (nullptr if not found)
- **Integrated into initialize** ‚Äî MaterialSystem parses optional "states.vertexFormats" JSON section; detects duplicate IDs with console::fatal
- **JSON structure** ‚Äî vertexFormats defined as object in states section with format IDs as keys; each format has id, stride, elements array (semantic, format, offset per element)

### Atomic Functionalities Completed
1. **AF1: Extend parseFormat** ‚Äî Added R32G32B32_FLOAT, R32G32_FLOAT, R32_FLOAT to format mapping; test verifies all vertex formats parse correctly
2. **AF2: Add parseVertexFormat** ‚Äî Created StateBlockParser::parseVertexFormat extracting id, stride, elements; calls parseFormat for each element's format field; uses struct defaults for optional fields
3. **AF3: Add vertex format storage** ‚Äî Added m_vertexFormats unordered_map to MaterialSystem; implemented getVertexFormat query method returning const VertexFormat*
4. **AF4: Parse vertexFormats section** ‚Äî Updated MaterialSystem::initialize to parse states.vertexFormats if present; iterates formats, parses with StateBlockParser, checks duplicates, stores in map
5. **AF5: Add integration test** ‚Äî Created test with PositionColor and PositionNormalUV formats in JSON; verifies MaterialSystem loads and queries formats correctly

### Tests Added/Updated
- Added 3 T209 tests tagged [vertex-format][T209]:
  - "parseFormat supports vertex-specific formats" ‚Äî Unit test verifying R32G32B32_FLOAT, R32G32_FLOAT, R32_FLOAT parse correctly
  - "parseVertexFormat parses complete vertex format from JSON" ‚Äî Unit test with PositionNormalUV format JSON; verifies all 3 elements parsed with correct semantic/format/offset
  - "MaterialSystem loads and queries vertex formats" ‚Äî Integration test with PositionColor and PositionNormalUV in JSON; verifies initialize/query/nullptr for missing

### Files Modified
- `src/graphics/material_system/state_parser.h` ‚Äî Added parseVertexFormat declaration to StateBlockParser
- `src/graphics/material_system/state_parser.cpp` ‚Äî Extended parseFormat mapping with 3 vertex formats; implemented parseVertexFormat (48 lines extracting id/stride/elements)
- `src/graphics/material_system/material_system.h` ‚Äî Added m_vertexFormats map storage; added getVertexFormat query method
- `src/graphics/material_system/material_system.cpp` ‚Äî Added vertexFormats parsing section in initialize (17 lines after renderTargetStates); implemented getVertexFormat query
- `tests/material_system_tests.cpp` ‚Äî Added 3 T209 test cases after T208 tests

### Test Results
```
unit_test_runner.exe "[T209]" --durations yes
All tests passed (46 assertions in 3 test cases)
  0.015s: MaterialSystem loads and queries vertex formats
  0.000s: parseVertexFormat parses complete vertex format from JSON
  0.000s: parseFormat supports vertex-specific formats

unit_test_runner.exe "[material-system]"
All tests passed (136 assertions in 17 test cases)
```

### Implementation Details
**parseFormat Extension:**
```cpp
// Added to existing mapping in state_parser.cpp
{ "R32G32B32_FLOAT", DXGI_FORMAT_R32G32B32_FLOAT },  // POSITION, NORMAL
{ "R32G32_FLOAT", DXGI_FORMAT_R32G32_FLOAT },        // TEXCOORD
{ "R32_FLOAT", DXGI_FORMAT_R32_FLOAT },              // Generic float
```

**parseVertexFormat Pattern:**
- Follows same structure as other state block parsers (parseRasterizer, parseDepthStencil, etc.)
- Extracts required fields: id (string), stride (UINT), elements (array)
- For each element: semantic (string), format (via parseFormat), offset (UINT to alignedByteOffset)
- Optional fields (semanticIndex, inputSlot, inputSlotClass, instanceDataStepRate) use VertexElement struct defaults

**MaterialSystem Integration:**
- vertexFormats parsed after renderTargetStates in initialize (optional section)
- Follows state block pattern: iterate JSON object items, parse format, check duplicate IDs, store by id
- getVertexFormat query returns const pointer (nullptr if not found, consistent with other state queries)

**JSON Example:**
```json
{
  "states": {
    "vertexFormats": {
      "PositionNormalUV": {
        "id": "PositionNormalUV",
        "stride": 32,
        "elements": [
          { "semantic": "POSITION", "format": "R32G32B32_FLOAT", "offset": 0 },
          { "semantic": "NORMAL", "format": "R32G32B32_FLOAT", "offset": 12 },
          { "semantic": "TEXCOORD", "format": "R32G32_FLOAT", "offset": 24 }
        ]
      }
    }
  }
}
```

### Notes
- Completes 2/4 tasks in Phase 2C (Vertex Formats)
- Vertex formats now fully parseable from JSON with DXGI format mapping
- MaterialSystem provides centralized vertex format storage and query (same pattern as state blocks)
- Supports typical vertex elements: POSITION/NORMAL (R32G32B32_FLOAT), TEXCOORD (R32G32_FLOAT), COLOR (R32G32B32A32_FLOAT)
- Next: T210 will add vertexFormat reference field to MaterialDefinition; T211 will use formats in PipelineBuilder to replace hardcoded POSITION+COLOR layout

---

## ‚úÖ T203: Update PipelineBuilder to Use Shader Info ‚Äî COMPLETED

**Date**: 2025-10-10  
**Status**: ‚úÖ All tests passing (5 assertions in pipeline-builder tests, 79 in full material-system)

### Implementation Summary
- **Removed hardcoded shader paths** ‚Äî Replaced `shaderPath = "shaders/simple.hlsl"` with iteration over `material.shaders`
- **Dynamic shader compilation** ‚Äî For each `ShaderReference`, calls `MaterialShaderCompiler::CompileWithDefines()` with `file`, `entryPoint`, `profile` from parsed data
- **Stage-based bytecode population** ‚Äî Maps compiled blobs to PSO descriptor fields based on `ShaderStage` enum (Vertex‚ÜíVS, Pixel‚ÜíPS, Domain‚ÜíDS, Hull‚ÜíHS, Geometry‚ÜíGS)
- **Per-shader defines support** ‚Äî Converts `shaderRef.defines` vector to map and passes to compiler; enables per-shader conditional compilation
- **Required shader validation** ‚Äî Fatal error if Vertex shader missing for graphics PSO; ensures valid PSO configuration

### Atomic Functionalities Completed
1. **AF1: Test for shader info usage** ‚Äî Created test with grid.hlsl material; verifies PSO compiles from material-specified shaders not hardcoded simple.hlsl
2. **AF2: Iterate material.shaders** ‚Äî Replaced hardcoded shader compilation with loop over `material.shaders`; calls `CompileWithDefines` with shader-specific parameters
3. **AF3: Stage-based bytecode** ‚Äî Switch statement maps `ShaderStage` enum to correct `D3D12_GRAPHICS_PIPELINE_STATE_DESC` fields (VS, PS, DS, HS, GS)
4. **AF4: Per-shader defines** ‚Äî Converts `shaderRef.defines` vector to `unordered_map<string, string>` with empty values (flag-style defines); passes to compiler
5. **AF5: Missing shader validation** ‚Äî Fatal error if `vsBlob` null after shader compilation; prevents invalid graphics PSO creation

### Tests Added/Updated
- Added T203 test: "PipelineBuilder compiles shaders from material shader info" using grid.hlsl
- Updated T014 tests to use vs_5_0/ps_5_0 profiles (compiler compatibility)
- Updated T201/T202 tests to use vs_5_0/ps_5_0 profiles
- All pipeline-builder tests pass (3 test cases, 5 assertions)

### Files Modified
- `src/graphics/material_system/pipeline_builder.cpp` ‚Äî Replaced hardcoded shader compilation with dynamic iteration; added stage mapping, defines conversion, validation
- `tests/material_system_tests.cpp` ‚Äî Added T203 test; updated shader profiles in T014, T201, T202 tests to vs_5_0/ps_5_0

### Test Results
```
unit_test_runner.exe "[pipeline-builder]"
All tests passed (5 assertions in 3 test cases)

unit_test_runner.exe "[material-system]"  
All tests passed (79 assertions in 12 test cases)
```

### Implementation Details
- **Shader Compilation Loop**: Iterates `material.shaders`, compiles each with `file`/`entry`/`profile` from ShaderReference
- **Bytecode Storage**: Stores compiled blobs in ComPtr variables (vsBlob, psBlob, dsBlob, hsBlob, gsBlob) based on stage
- **Defines Conversion**: Shader defines are flag-style (`#define IS_PREPASS`), so convert vector‚Üímap with empty string values
- **Stage Mapping**: Switch on `ShaderStage` enum to populate correct PSO descriptor field
- **Compute Shader Rejection**: Returns error if Compute stage present (not valid for graphics PSO)
- **Validation**: Fatal error if Vertex shader missing; other stages optional depending on pipeline configuration

### Notes
- Completes Phase 2A (Shader Information) ‚Äî all hard-coded shader references eliminated
- PSO creation now fully data-driven for shader compilation stage
- Next: Phase 2B (State Blocks) ‚Äî T204-T207 for rasterizer/depth/blend states
- Shader profile validation still enforces (vs|ps|ds|hs|gs|cs)_X_Y regex from T202
- Material-level defines not yet merged (future enhancement); currently only per-shader defines supported

---

## ‚úÖ T202: Update MaterialParser to Extract Shader Info ‚Äî COMPLETED

**Date**: 2025-01-08  
**Status**: ‚úÖ All tests passing (56 assertions in material-parser tests, 79 in full material-system)

### Implementation Summary
- **Removed legacy string mode support** ‚Äî Parser now requires inline shader objects with `file`, `entry`, `profile` fields
- **Added file path validation** ‚Äî Checks shader file exists using `std::filesystem::exists()`, calls `console::fatal()` if missing
- **Added duplicate shader stage detection** ‚Äî Uses `std::unordered_set<ShaderStage>` to detect duplicate stages, calls `console::fatal()` on duplicates
- **Profile regex validation** ‚Äî Enforces `(vs|ps|ds|hs|gs|cs)_\d+_\d+` format
- **Default values preserved** ‚Äî `entry` defaults to "main", `defines` defaults to empty vector from T201

### Atomic Functionalities Completed
1. **AF1: File validation** ‚Äî Parser validates shader file exists relative to working directory
2. **AF2: Legacy mode removal** ‚Äî String mode rejected with fatal error explaining new format required
3. **AF3: Duplicate detection** ‚Äî Prevents multiple shaders with same stage (e.g., two "vertex" shaders)

### Tests Updated
- Updated T009, T014, T201 tests to use inline shader objects instead of string format
- Updated T010 tests (ReferenceValidator) to use inline shader objects
- Updated T015 test (MaterialSystem handle-based API) to use inline shader objects  
- Updated T016 integration test to use inline shader objects
- Converted `materials.json` project file from legacy string format to inline shader objects

### Files Modified
- `src/graphics/material_system/parser.cpp` ‚Äî Added file validation, removed string mode support, added duplicate detection
- `tests/material_system_tests.cpp` ‚Äî Updated 6 test cases (T009, T010, T014, T015, T016, T201) to use inline format
- `materials.json` ‚Äî Converted 5 materials (standard_opaque, unlit_opaque, grid_material, wireframe, debug_normals) to inline shader format

### Test Results
```
unit_test_runner.exe "[material-parser]"
All tests passed (56 assertions in 5 test cases)

unit_test_runner.exe "[material-system]"  
All tests passed (79 assertions in 12 test cases)
```

### Validation Behavior
- **Missing file**: `console::fatal("Shader file 'path' does not exist")` ‚Äî Terminates immediately
- **Legacy string**: `console::fatal("Legacy string shader references no longer supported. Shader 'X' in material 'Y' must be an object with 'file', 'profile', etc.")` ‚Äî Guides migration
- **Duplicate stage**: `console::fatal("Duplicate shader stage 'vertex' in material 'mat_id'")` ‚Äî Prevents ambiguous configurations
- **Invalid profile**: `console::fatal("Invalid shader profile 'X'. Must match (vs|ps|ds|hs|gs|cs)_N_M")` ‚Äî Enforces DirectX shader model format

### Notes
- All project materials now use inline shader format ‚Äî no legacy string references remain
- Parser is now strict: fails fast on any validation error
- Shader file paths validated before PSO building (fail-fast at load time, not render time)
- Completes 2/3 tasks in Phase 2A (Shader Information)

---

## ‚úÖ T201: Extend ShaderReference Struct ‚Äî COMPLETED

**Date**: 2025-10-10  
**Status**: ‚úÖ All tests passing (20 assertions)

### Implementation Summary
- Extended `ShaderReference` struct with: `file`, `entryPoint`, `profile`, `defines` fields
- Parser supports both legacy string mode (`"vs": "shader_id"`) and new object mode (`"vs": {"file": "...", ...}`)
- Profile validation with regex: `(vs|ps|ds|hs|gs|cs)_\d+_\d+`
- Default values: `entryPoint` defaults to "main", `defines` defaults to empty
- Backward compatibility maintained ‚Äî all existing tests pass

### Tests Added
1. `MaterialParser parses shader with all fields present` ‚Äî Verifies file, entryPoint, profile, defines parsed correctly
2. `MaterialParser parses shader with missing optional fields and applies defaults` ‚Äî Verifies defaults applied

### Files Modified
- `src/graphics/material_system/parser.h` ‚Äî Extended ShaderReference struct
- `src/graphics/material_system/parser.cpp` ‚Äî Updated shader parsing logic with validation
- `tests/material_system_tests.cpp` ‚Äî Added T201 tests, fixed legacy test syntax

### Test Results
```
unit_test_runner.exe "[material-parser][T201]"
All tests passed (20 assertions in 2 test cases)

unit_test_runner.exe "[material-system]"  
All tests passed (79 assertions in 12 test cases)
```

### Notes
- Fatal error cases (missing file, invalid profile) documented but not unit tested (console::fatal terminates process)
- Legacy shader ID references still supported for gradual migration
- Completes 1/3 tasks in Phase 2A (Shader Information)

---

## ‚úÖ T204: Define State Block Structs ‚Äî COMPLETED

**Date**: 2025-10-10  
**Status**: ‚úÖ All tests passing (85 assertions in state-blocks tests, 79 in full material-system)

### Implementation Summary
- **Created `state_blocks.h`** ‚Äî Defines 5 struct types for JSON state block storage
- **All default values match D3D12** ‚Äî Fields initialized to D3D12 default constants (FILL_MODE_SOLID, CULL_MODE_BACK, COMPARISON_FUNC_LESS, etc.)
- **Conversion methods** ‚Äî `BlendRenderTargetState::toD3D12()` and `DepthStencilOpDesc::toD3D12()` convert to D3D12 descriptors
- **Inheritance support** ‚Äî All structs have optional `base` field for state block inheritance (T205 will implement resolution)
- **Comprehensive coverage** ‚Äî All state categories needed for graphics PSO: rasterizer, depth/stencil, blend, render target format

### Atomic Functionalities Completed
1. **AF1: RasterizerStateBlock struct** ‚Äî 13 fields (fillMode, cullMode, frontCCW, depthBias, depthBiasClamp, slopeScaledDepthBias, depthClipEnable, multisampleEnable, antialiasedLineEnable, forcedSampleCount, conservativeRaster, base)
2. **AF2: DepthStencilStateBlock struct** ‚Äî 8 fields + 2 stencil op descriptors (depthEnable, depthWriteMask, depthFunc, stencilEnable, stencilReadMask, stencilWriteMask, frontFace, backFace, base)
3. **AF3: BlendRenderTargetState struct** ‚Äî Blend descriptor with toD3D12() conversion (blendEnable, logicOpEnable, srcBlend, destBlend, blendOp, srcBlendAlpha, destBlendAlpha, blendOpAlpha, logicOp, renderTargetWriteMask)
4. **AF4: BlendStateBlock struct** ‚Äî Alpha-to-coverage, independent blend, array of 8 render targets (alphaToCoverageEnable, independentBlendEnable, renderTargets[8], base)
5. **AF5: RenderTargetStateBlock struct** ‚Äî RT format and blend descriptors (format, blendDesc)

### Tests Added
1. `RasterizerStateBlock has correct default values` ‚Äî Verifies all 11 state fields match D3D12 defaults
2. `DepthStencilStateBlock has correct default values` ‚Äî Verifies depth/stencil enable, masks, comparison func, stencil ops
3. `BlendRenderTargetState has correct default values` ‚Äî Verifies blend factors, ops, write mask defaults
4. `BlendStateBlock has correct default values` ‚Äî Verifies alpha-to-coverage, independent blend, RT array defaults
5. `RenderTargetStateBlock has correct default values` ‚Äî Verifies DXGI_FORMAT_R8G8B8A8_UNORM default, blend desc
6. `BlendRenderTargetState::toD3D12() converts to D3D12_RENDER_TARGET_BLEND_DESC` ‚Äî Tests conversion accuracy
7. `DepthStencilOpDesc::toD3D12() converts to D3D12_DEPTH_STENCILOP_DESC` ‚Äî Tests stencil op conversion

### Files Modified
- Created: `src/graphics/material_system/state_blocks.h` ‚Äî 113 lines, 5 struct definitions
- Updated: `tests/material_system_tests.cpp` ‚Äî Added `#include <graphics/material_system/state_blocks.h>`, 7 test cases with 85 assertions

### Test Results
```
unit_test_runner.exe "[state-blocks][T204]"
All tests passed (85 assertions in 7 test cases)

unit_test_runner.exe "[material-system]"  
All tests passed (79 assertions in 12 test cases)
```

### Implementation Details
- **Default values rationale**: Match D3D12 PSO defaults exactly to ensure no behavior changes when states unspecified
- **Struct organization**: Each state category is separate struct; MaterialDefinition will contain optional fields for each
- **Inheritance mechanism**: `base` field (string, optional) references another state block ID; parser will resolve inheritance chains
- **Conversion methods**: toD3D12() methods provide type-safe conversion to D3D12 descriptor structs
- **Array sizing**: BlendStateBlock has 8 render targets (D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT)

### Notes
- Completes 1/4 tasks in Phase 2B (State Blocks)
- Structs provide foundation for T205 (JSON parsing) and T206 (MaterialSystem integration)
- All defaults carefully verified against D3D12 documentation to ensure correct PSO behavior
- Next: T205 will implement string‚Üíenum mappings for JSON parsing (FillMode, CullMode, ComparisonFunc, Blend factors, etc.)

---

## ‚úÖ T206: Integrate State Blocks into MaterialSystem ‚Äî COMPLETED

**Date**: 2025-10-10  
**Status**: ‚úÖ All tests passing (32 assertions in T206 integration tests)

### Implementation Summary
- **Added state block storage to MaterialSystem** ‚Äî 4 unordered_map containers for rasterizer, depth/stencil, blend, and render target states keyed by ID
- **Integrated state parsing** ‚Äî MaterialSystem::initialize() now parses optional "states" section from merged JSON using StateBlockParser
- **Implemented query methods** ‚Äî 4 public methods to retrieve state blocks by ID returning const pointers (nullptr if not found)
- **Duplicate detection** ‚Äî console::fatal when duplicate state block ID detected within same category
- **Optional states section** ‚Äî If no "states" section exists, no state blocks loaded (backward compatible)

### Atomic Functionalities Completed
1. **AF1: Add state storage maps** ‚Äî Added 4 private member maps: `m_rasterizerStates`, `m_depthStencilStates`, `m_blendStates`, `m_renderTargetStates`
2. **AF2: Parse rasterizer states** ‚Äî In initialize(), iterate "states.rasterizerStates" array, parse with StateBlockParser::parseRasterizer, detect duplicates, store in map
3. **AF3: Parse depth/stencil states** ‚Äî Parse "states.depthStencilStates" array with StateBlockParser::parseDepthStencil
4. **AF4: Parse blend states** ‚Äî Parse "states.blendStates" array with StateBlockParser::parseBlend
5. **AF5: Parse render target states** ‚Äî Parse "states.renderTargetStates" array with StateBlockParser::parseRenderTarget
6. **AF6: Query methods** ‚Äî Implemented getRasterizerState, getDepthStencilState, getBlendState, getRenderTargetState with map.find() returning const pointer or nullptr

### Tests Added
1. `MaterialSystem loads and queries rasterizer states from JSON` ‚Äî Tests loading 2 rasterizer state blocks (wireframe_rast, default_rast) with different fillMode; verifies query returns correct state, nullptr for non-existent ID (8 assertions)
2. `MaterialSystem loads and queries depth stencil states from JSON` ‚Äî Tests loading 2 depth/stencil states (depth_only, depth_stencil_enabled) with different depthEnable/stencilEnable; verifies query accuracy (8 assertions)
3. `MaterialSystem loads and queries blend states from JSON` ‚Äî Tests loading 2 blend states (opaque_blend, alpha_blend) with different blendEnable on RT0; verifies query returns correct configuration (8 assertions)
4. `MaterialSystem loads and queries render target states from JSON` ‚Äî Tests loading 2 RT states (single_rt, multi_rt) with different format counts; verifies query and nullptr behavior (8 assertions)

### Files Modified
- `src/graphics/material_system/material_system.h` ‚Äî Added state_blocks.h include, 4 public query method declarations, 4 private storage maps (unordered_map<string, StateBlock>)
- `src/graphics/material_system/material_system.cpp` ‚Äî Added state_parser.h include, implemented state parsing in initialize() with duplicate detection, implemented 4 query methods
- `tests/material_system_tests.cpp` ‚Äî Added 4 integration tests for T206 with [material-system][T206] tags

### Test Results
```
unit_test_runner.exe "[material-system][T206]"
All tests passed (32 assertions in 4 test cases)

unit_test_runner.exe "[material-system]"  
All tests passed (111 assertions in 16 test cases)
```

### Implementation Details
- **State parsing pattern**: Check if "states" key exists in merged JSON; for each category (rasterizerStates, etc.), iterate array, parse with StateBlockParser, check for duplicate ID with map.count(), call console::fatal if duplicate found, store in map
- **Query method pattern**: Use map.find(); return &iter->second if found, nullptr otherwise
- **No fatal errors on missing states**: Query methods return nullptr to allow optional state usage (PipelineBuilder can fall back to defaults)
- **Inheritance not yet resolved**: base field extracted by parsers but not dereferenced; state blocks must be self-contained for now (inheritance implementation deferred pending T207 requirements)
- **All state categories supported**: Rasterizer (fillMode, cullMode, etc.), DepthStencil (depthEnable, stencilOps, etc.), Blend (alphaToCoverage, per-RT blend), RenderTarget (rtvFormats, dsvFormat, sample desc)

### JSON Structure Example
```json
{
  "states": {
    "rasterizerStates": [
      {
        "id": "wireframe_rast",
        "fillMode": "Wireframe",
        "cullMode": "None"
      }
    ],
    "depthStencilStates": [
      {
        "id": "depth_only",
        "depthEnable": true,
        "depthWriteMask": "All",
        "depthFunc": "Less"
      }
    ]
  }
}
```

### Notes
- Completes 3/4 tasks in Phase 2B (State Blocks)
- MaterialSystem now stores state blocks globally (shared across all materials) ‚Äî materials reference by ID
- Duplicate detection prevents conflicting state definitions
- Query methods provide type-safe access with nullptr fallback for missing states
- Next: T207 will update PipelineBuilder::buildPSO() to query MaterialSystem for state blocks instead of using hardcoded D3D12 defaults
- Inheritance resolution (base field processing) deferred ‚Äî will implement if T207 requires it; current tests validate standalone state blocks only

---

## ‚úÖ T205: Create State Block Parser ‚Äî COMPLETED

**Date**: 2025-10-10  
**Status**: ‚úÖ All tests passing (96 assertions in state-parser tests, 79 in full material-system)

### Implementation Summary
- **Created StateBlockParser class** ‚Äî Provides static parse methods for all state block types plus enum string‚ÜíD3D12 mappings
- **Implemented 10 enum parsers** ‚Äî FillMode, CullMode, ComparisonFunc, BlendFactor, BlendOp, LogicOp, StencilOp, DepthWriteMask, ColorWriteMask, DXGI_FORMAT
- **Full state block parsers** ‚Äî parseRasterizer, parseDepthStencil, parseBlend, parseRenderTarget extract all fields from JSON
- **Optional field support** ‚Äî All fields optional except id; defaults from struct definitions used when JSON omits fields
- **Type-safe parsing** ‚Äî String‚Üíenum mappings with console::fatal for invalid values

### Atomic Functionalities Completed
1. **AF1-AF5: Enum parsers** ‚Äî parseFillMode (Solid/Wireframe), parseCullMode (None/Front/Back), parseComparisonFunc (8 functions), parseBlendFactor (17 factors), parseBlendOp (5 operations) plus StencilOp, DepthWriteMask, ColorWriteMask, LogicOp, parseFormat
2. **AF6: RasterizerStateBlock parser** ‚Äî Parses fillMode, cullMode, frontCounterClockwise, depthBias, depthBiasClamp, slopeScaledDepthBias, depthClipEnable, multisampleEnable, antialiasedLineEnable, forcedSampleCount, conservativeRaster, id, base fields
3. **AF7: DepthStencilStateBlock parser** ‚Äî Parses depthEnable, depthWriteMask, depthFunc, stencilEnable, stencilReadMask, stencilWriteMask, frontFace stencil ops, backFace stencil ops with nested object parsing
4. **AF8: BlendStateBlock parser** ‚Äî Parses alphaToCoverageEnable, independentBlendEnable, renderTargets array (up to 8) with per-target blend descriptors (blendEnable, srcBlend, destBlend, blendOp, srcBlendAlpha, destBlendAlpha, blendOpAlpha, logicOp, renderTargetWriteMask)
5. **AF9: RenderTargetStateBlock parser** ‚Äî Parses rtvFormats array, dsvFormat, sampleCount, sampleQuality

### Tests Added
1. `StateBlockParser parses FillMode strings correctly` ‚Äî Solid‚ÜíSOLID, Wireframe‚ÜíWIREFRAME (2 assertions)
2. `StateBlockParser parses CullMode strings correctly` ‚Äî None, Front, Back mappings (3 assertions)
3. `StateBlockParser parses ComparisonFunc strings correctly` ‚Äî All 8 comparison functions (8 assertions)
4. `StateBlockParser parses Blend factor strings correctly` ‚Äî Zero, One, SrcColor, InvSrcColor, SrcAlpha, InvSrcAlpha, etc. (10 assertions)
5. `StateBlockParser parses BlendOp strings correctly` ‚Äî Add, Subtract, RevSubtract, Min, Max (5 assertions)
6. `StateBlockParser parses StencilOp strings correctly` ‚Äî Keep, Zero, Replace, IncrSat, DecrSat, Invert, Incr, Decr (8 assertions)
7. `StateBlockParser parses DepthWriteMask strings correctly` ‚Äî Zero, All (2 assertions)
8. `StateBlockParser parses ColorWriteMask strings correctly` ‚Äî Red, Green, Blue, Alpha, All (5 assertions)
9. `StateBlockParser parses DXGI_FORMAT strings correctly` ‚Äî R8G8B8A8_UNORM, R16G16B16A16_FLOAT, D32_FLOAT, etc. (6 assertions)
10. `StateBlockParser parses RasterizerStateBlock from JSON` ‚Äî Full struct with all fields (12 assertions)
11. `StateBlockParser parses DepthStencilStateBlock from JSON` ‚Äî Depth/stencil fields plus frontFace/backFace nested objects (15 assertions)
12. `StateBlockParser parses BlendStateBlock from JSON` ‚Äî Alpha-to-coverage, independent blend, 2 render targets with blend descriptors (13 assertions)
13. `StateBlockParser parses RenderTargetStateBlock from JSON` ‚Äî rtvFormats array, dsvFormat, sample count/quality (7 assertions)

### Files Modified
- Created: `src/graphics/material_system/state_parser.h` ‚Äî Class declaration with parse methods
- Created: `src/graphics/material_system/state_parser.cpp` ‚Äî 530 lines, all parsers implemented with string‚Üíenum mappings
- Updated: `tests/material_system_tests.cpp` ‚Äî Added 13 test cases with 96 assertions tagged [state-parser][T205]
- Updated: `CMakeLists.txt` ‚Äî Added state_parser.cpp to graphics library sources

### Test Results
```
unit_test_runner.exe "[state-parser][T205]"
All tests passed (96 assertions in 13 test cases)

unit_test_runner.exe "[material-system]"  
All tests passed (79 assertions in 12 test cases)
```

### Implementation Details
- **String‚Üíenum mapping strategy**: Static unordered_map in each parse function; O(1) lookup; console::fatal for invalid strings
- **JSON parsing pattern**: Check contains() && is_<type>() before extracting; allows optional fields with struct defaults
- **Boolean conversion**: JSON bool ‚Üí Win32 BOOL via ternary operator (`value ? TRUE : FALSE`)
- **Array parsing**: BlendStateBlock iterates renderTargets array with `std::min(jsonSize, 8)` to respect D3D12 limit
- **Nested object parsing**: frontFace/backFace stencil ops parsed from nested JSON objects with separate contain checks per field
- **Format parsing**: Covers common RT formats (R8G8B8A8_UNORM, R16G16B16A16_FLOAT, etc.) and depth formats (D32_FLOAT, D24_UNORM_S8_UINT, D16_UNORM)
- **Conservative rasterization**: Boolean in JSON ‚Üí D3D12_CONSERVATIVE_RASTERIZATION_MODE enum (ON/OFF)

### Notes
- Completes 2/4 tasks in Phase 2B (State Blocks)
- No inheritance resolution yet ‚Äî id and base fields extracted but not processed (deferred to T206)
- Invalid enum strings produce descriptive fatal errors with list of valid values
- All parsers handle missing optional fields gracefully using struct defaults from T204
- Next: T206 will integrate parsers into MaterialSystem, resolve inheritance, store state blocks in maps

---

## ‚è≥ Next Steps

**Phase 2B: State Blocks (T204-T207)**
- ‚úÖ T204: Define State Block Structs ‚Äî COMPLETED
- ‚úÖ T205: Create State Block Parser ‚Äî COMPLETED
- T206: Integrate State Blocks ‚Äî Store state blocks in material system
- T207: Update PipelineBuilder (States) ‚Äî Use state blocks instead of hardcoded D3D12 defaults

---

## üìä Phase 2 Progress Tracker

| Task | Status | Tests | Notes |
|------|--------|-------|-------|
| T201: Extend ShaderReference Struct | ‚úÖ Complete | 2 tests, 20 assertions | Struct extended, parser updated |
| T202: Update MaterialParser | ‚úÖ Complete | 56 assertions (material-parser) | File validation, duplicate detection, legacy mode removed |
| T203: Update PipelineBuilder | ‚úÖ Complete | 5 assertions (pipeline-builder) | Dynamic shader compilation from material data |
| T204: Define State Block Structs | ‚úÖ Complete | 7 tests, 85 assertions | 5 structs with D3D12 defaults |
| T205: Create State Block Parser | ‚úÖ Complete | 13 tests, 96 assertions | Enum parsers + state block parsers |
| T206: Integrate State Blocks | ‚úÖ Complete | 4 tests, 32 assertions | State storage + query methods |
| T207: Update PipelineBuilder (States) | ‚úÖ Complete | 3 tests, 12 assertions (T207) | State block queries replace hardcoded D3D12 defaults |
| T208: Define VertexFormat Structs | ‚úÖ Complete | 2 tests, 13 assertions | VertexElement + VertexFormat structs |
| T209: Parse Vertex Formats | ‚úÖ Complete | 3 tests, 46 assertions | parseVertexFormat + MaterialSystem integration |
| T210: Add vertexFormat to MaterialDef | ‚è≥ Pending | Pending | Phase 2C |
| T211: Use Vertex Format in PSO | ‚è≥ Pending | Pending | Phase 2C |
| T214: Build Root Signature from Spec | ‚è≥ Pending | Pending | Phase 2D |
| T215: Use Root Sig from Cache | ‚è≥ Pending | Pending | Phase 2D |
| T216: Parse Render Passes | ‚è≥ Pending | Pending | Phase 2E |
| T217: Generate RenderPassConfig | ‚è≥ Pending | Pending | Phase 2E |
| T212: Add Primitive Topology | ‚è≥ Pending | Pending | Phase 2E |
| T213: Sample Desc from RT State | ‚è≥ Pending | Pending | Phase 2E |

**Overall Progress**: 8/17 tasks complete (47.1%)

---

## üìö References

- **Phase 2 Plan**: `specs/001-data-driven-material/PHASE2_IMPLEMENTATION_PLAN.md`
- **Phase 1 Progress**: See `PROGRESS_2.md` entries for T001-T016
- **Milestone Progress**: `PROGRESS_2.md`
